<!DOCTYPE HTML>
<html lang>
<head>
<!-- Generated by javadoc (21) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: eu.righettod, class: SecurityUtils">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">package eu.righettod;</span>
<span class="source-line-no">002</span><span id="line-2"></span>
<span class="source-line-no">003</span><span id="line-3"></span>
<span class="source-line-no">004</span><span id="line-4">import com.auth0.jwt.interfaces.DecodedJWT;</span>
<span class="source-line-no">005</span><span id="line-5">import org.apache.commons.csv.CSVFormat;</span>
<span class="source-line-no">006</span><span id="line-6">import org.apache.commons.csv.CSVRecord;</span>
<span class="source-line-no">007</span><span id="line-7">import org.apache.commons.imaging.ImageInfo;</span>
<span class="source-line-no">008</span><span id="line-8">import org.apache.commons.imaging.Imaging;</span>
<span class="source-line-no">009</span><span id="line-9">import org.apache.commons.imaging.common.ImageMetadata;</span>
<span class="source-line-no">010</span><span id="line-10">import org.apache.commons.validator.routines.EmailValidator;</span>
<span class="source-line-no">011</span><span id="line-11">import org.apache.commons.validator.routines.InetAddressValidator;</span>
<span class="source-line-no">012</span><span id="line-12">import org.apache.pdfbox.Loader;</span>
<span class="source-line-no">013</span><span id="line-13">import org.apache.pdfbox.pdmodel.PDDocument;</span>
<span class="source-line-no">014</span><span id="line-14">import org.apache.pdfbox.pdmodel.PDDocumentCatalog;</span>
<span class="source-line-no">015</span><span id="line-15">import org.apache.pdfbox.pdmodel.PDDocumentInformation;</span>
<span class="source-line-no">016</span><span id="line-16">import org.apache.pdfbox.pdmodel.PDDocumentNameDictionary;</span>
<span class="source-line-no">017</span><span id="line-17">import org.apache.pdfbox.pdmodel.common.PDMetadata;</span>
<span class="source-line-no">018</span><span id="line-18">import org.apache.pdfbox.pdmodel.interactive.action.*;</span>
<span class="source-line-no">019</span><span id="line-19">import org.apache.pdfbox.pdmodel.interactive.annotation.AnnotationFilter;</span>
<span class="source-line-no">020</span><span id="line-20">import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;</span>
<span class="source-line-no">021</span><span id="line-21">import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLink;</span>
<span class="source-line-no">022</span><span id="line-22">import org.apache.poi.poifs.filesystem.DirectoryEntry;</span>
<span class="source-line-no">023</span><span id="line-23">import org.apache.poi.poifs.filesystem.POIFSFileSystem;</span>
<span class="source-line-no">024</span><span id="line-24">import org.apache.poi.poifs.macros.VBAMacroReader;</span>
<span class="source-line-no">025</span><span id="line-25">import org.apache.tika.detect.DefaultDetector;</span>
<span class="source-line-no">026</span><span id="line-26">import org.apache.tika.detect.Detector;</span>
<span class="source-line-no">027</span><span id="line-27">import org.apache.tika.io.TemporaryResources;</span>
<span class="source-line-no">028</span><span id="line-28">import org.apache.tika.io.TikaInputStream;</span>
<span class="source-line-no">029</span><span id="line-29">import org.apache.tika.metadata.Metadata;</span>
<span class="source-line-no">030</span><span id="line-30">import org.apache.tika.mime.MediaType;</span>
<span class="source-line-no">031</span><span id="line-31">import org.apache.tika.mime.MimeTypes;</span>
<span class="source-line-no">032</span><span id="line-32">import org.w3c.dom.Document;</span>
<span class="source-line-no">033</span><span id="line-33">import org.xml.sax.EntityResolver;</span>
<span class="source-line-no">034</span><span id="line-34">import org.xml.sax.InputSource;</span>
<span class="source-line-no">035</span><span id="line-35">import org.xml.sax.SAXException;</span>
<span class="source-line-no">036</span><span id="line-36"></span>
<span class="source-line-no">037</span><span id="line-37">import javax.crypto.Mac;</span>
<span class="source-line-no">038</span><span id="line-38">import javax.crypto.spec.SecretKeySpec;</span>
<span class="source-line-no">039</span><span id="line-39">import javax.imageio.ImageIO;</span>
<span class="source-line-no">040</span><span id="line-40">import javax.json.Json;</span>
<span class="source-line-no">041</span><span id="line-41">import javax.json.JsonReader;</span>
<span class="source-line-no">042</span><span id="line-42">import javax.xml.XMLConstants;</span>
<span class="source-line-no">043</span><span id="line-43">import javax.xml.parsers.DocumentBuilder;</span>
<span class="source-line-no">044</span><span id="line-44">import javax.xml.parsers.DocumentBuilderFactory;</span>
<span class="source-line-no">045</span><span id="line-45">import javax.xml.parsers.ParserConfigurationException;</span>
<span class="source-line-no">046</span><span id="line-46">import javax.xml.stream.XMLInputFactory;</span>
<span class="source-line-no">047</span><span id="line-47">import javax.xml.stream.XMLStreamReader;</span>
<span class="source-line-no">048</span><span id="line-48">import javax.xml.stream.events.XMLEvent;</span>
<span class="source-line-no">049</span><span id="line-49">import javax.xml.validation.Schema;</span>
<span class="source-line-no">050</span><span id="line-50">import javax.xml.validation.SchemaFactory;</span>
<span class="source-line-no">051</span><span id="line-51">import java.awt.*;</span>
<span class="source-line-no">052</span><span id="line-52">import java.awt.image.BufferedImage;</span>
<span class="source-line-no">053</span><span id="line-53">import java.io.*;</span>
<span class="source-line-no">054</span><span id="line-54">import java.net.*;</span>
<span class="source-line-no">055</span><span id="line-55">import java.net.http.HttpClient;</span>
<span class="source-line-no">056</span><span id="line-56">import java.net.http.HttpRequest;</span>
<span class="source-line-no">057</span><span id="line-57">import java.net.http.HttpResponse;</span>
<span class="source-line-no">058</span><span id="line-58">import java.nio.ByteBuffer;</span>
<span class="source-line-no">059</span><span id="line-59">import java.nio.charset.Charset;</span>
<span class="source-line-no">060</span><span id="line-60">import java.nio.charset.StandardCharsets;</span>
<span class="source-line-no">061</span><span id="line-61">import java.nio.file.Files;</span>
<span class="source-line-no">062</span><span id="line-62">import java.security.MessageDigest;</span>
<span class="source-line-no">063</span><span id="line-63">import java.security.SecureRandom;</span>
<span class="source-line-no">064</span><span id="line-64">import java.time.Duration;</span>
<span class="source-line-no">065</span><span id="line-65">import java.util.*;</span>
<span class="source-line-no">066</span><span id="line-66">import java.util.List;</span>
<span class="source-line-no">067</span><span id="line-67">import java.util.concurrent.*;</span>
<span class="source-line-no">068</span><span id="line-68">import java.util.concurrent.atomic.AtomicInteger;</span>
<span class="source-line-no">069</span><span id="line-69">import java.util.regex.Pattern;</span>
<span class="source-line-no">070</span><span id="line-70">import java.util.zip.ZipEntry;</span>
<span class="source-line-no">071</span><span id="line-71">import java.util.zip.ZipFile;</span>
<span class="source-line-no">072</span><span id="line-72"></span>
<span class="source-line-no">073</span><span id="line-73">/**</span>
<span class="source-line-no">074</span><span id="line-74"> * Provides different utilities methods to apply processing from a security perspective.&lt;br&gt;</span>
<span class="source-line-no">075</span><span id="line-75"> * These code snippet:</span>
<span class="source-line-no">076</span><span id="line-76"> * &lt;ul&gt;</span>
<span class="source-line-no">077</span><span id="line-77"> *     &lt;li&gt;Can be used, as "foundation", to customize the validation to the app context.&lt;/li&gt;</span>
<span class="source-line-no">078</span><span id="line-78"> *     &lt;li&gt;Were implemented in a way to facilitate adding or removal of validations depending on usage context.&lt;/li&gt;</span>
<span class="source-line-no">079</span><span id="line-79"> *     &lt;li&gt;Were centralized on one class to be able to enhance them across time as well as &lt;a href="https://github.com/righettod/code-snippets-security-utils/issues"&gt;missing case/bug identification&lt;/a&gt;.&lt;/li&gt;</span>
<span class="source-line-no">080</span><span id="line-80"> * &lt;/ul&gt;</span>
<span class="source-line-no">081</span><span id="line-81"> */</span>
<span class="source-line-no">082</span><span id="line-82">public class SecurityUtils {</span>
<span class="source-line-no">083</span><span id="line-83">    /**</span>
<span class="source-line-no">084</span><span id="line-84">     * Default constructor: Not needed as the class only provides static methods.</span>
<span class="source-line-no">085</span><span id="line-85">     */</span>
<span class="source-line-no">086</span><span id="line-86">    private SecurityUtils() {</span>
<span class="source-line-no">087</span><span id="line-87">    }</span>
<span class="source-line-no">088</span><span id="line-88"></span>
<span class="source-line-no">089</span><span id="line-89">    /**</span>
<span class="source-line-no">090</span><span id="line-90">     * Apply a collection of validation to verify if a provided PIN code is considered weak (easy to guess) or none.&lt;br&gt;</span>
<span class="source-line-no">091</span><span id="line-91">     * This method consider that format of the PIN code is [0-9]{6,}&lt;br&gt;</span>
<span class="source-line-no">092</span><span id="line-92">     * Rule to consider a PIN code as weak:</span>
<span class="source-line-no">093</span><span id="line-93">     * &lt;ul&gt;</span>
<span class="source-line-no">094</span><span id="line-94">     * &lt;li&gt;Length is inferior to 6 positions.&lt;/li&gt;</span>
<span class="source-line-no">095</span><span id="line-95">     * &lt;li&gt;Contain only the same number or only a sequence of zero.&lt;/li&gt;</span>
<span class="source-line-no">096</span><span id="line-96">     * &lt;li&gt;Contain sequence of following incremental or decremental numbers.&lt;/li&gt;</span>
<span class="source-line-no">097</span><span id="line-97">     * &lt;/ul&gt;</span>
<span class="source-line-no">098</span><span id="line-98">     *</span>
<span class="source-line-no">099</span><span id="line-99">     * @param pinCode PIN code to verify.</span>
<span class="source-line-no">100</span><span id="line-100">     * @return True only if the PIN is considered as weak.</span>
<span class="source-line-no">101</span><span id="line-101">     */</span>
<span class="source-line-no">102</span><span id="line-102">    public static boolean isWeakPINCode(String pinCode) {</span>
<span class="source-line-no">103</span><span id="line-103">        boolean isWeak = true;</span>
<span class="source-line-no">104</span><span id="line-104">        //Length is inferior to 6 positions</span>
<span class="source-line-no">105</span><span id="line-105">        //Use "Long.parseLong(pinCode)" to cause a NumberFormatException if the PIN is not a numeric one</span>
<span class="source-line-no">106</span><span id="line-106">        //and to ensure that the PIN is not only a sequence of zero</span>
<span class="source-line-no">107</span><span id="line-107">        if (pinCode != null &amp;&amp; Long.parseLong(pinCode) &gt; 0 &amp;&amp; pinCode.trim().length() &gt; 5) {</span>
<span class="source-line-no">108</span><span id="line-108">            //Contain only the same number</span>
<span class="source-line-no">109</span><span id="line-109">            String regex = String.format("^[%s]{%s}$", pinCode.charAt(0), pinCode.length());</span>
<span class="source-line-no">110</span><span id="line-110">            if (!Pattern.matches(regex, pinCode)) {</span>
<span class="source-line-no">111</span><span id="line-111">                //Contain sequence of following incremental or decremental numbers</span>
<span class="source-line-no">112</span><span id="line-112">                char previousChar = 'X';</span>
<span class="source-line-no">113</span><span id="line-113">                boolean containSequence = false;</span>
<span class="source-line-no">114</span><span id="line-114">                for (char c : pinCode.toCharArray()) {</span>
<span class="source-line-no">115</span><span id="line-115">                    if (previousChar != 'X') {</span>
<span class="source-line-no">116</span><span id="line-116">                        int previousNbr = Integer.parseInt(String.valueOf(previousChar));</span>
<span class="source-line-no">117</span><span id="line-117">                        int currentNbr = Integer.parseInt(String.valueOf(c));</span>
<span class="source-line-no">118</span><span id="line-118">                        if (currentNbr == (previousNbr - 1) || currentNbr == (previousNbr + 1)) {</span>
<span class="source-line-no">119</span><span id="line-119">                            containSequence = true;</span>
<span class="source-line-no">120</span><span id="line-120">                            break;</span>
<span class="source-line-no">121</span><span id="line-121">                        }</span>
<span class="source-line-no">122</span><span id="line-122">                    }</span>
<span class="source-line-no">123</span><span id="line-123">                    previousChar = c;</span>
<span class="source-line-no">124</span><span id="line-124">                }</span>
<span class="source-line-no">125</span><span id="line-125">                if (!containSequence) {</span>
<span class="source-line-no">126</span><span id="line-126">                    isWeak = false;</span>
<span class="source-line-no">127</span><span id="line-127">                }</span>
<span class="source-line-no">128</span><span id="line-128">            }</span>
<span class="source-line-no">129</span><span id="line-129">        }</span>
<span class="source-line-no">130</span><span id="line-130">        return isWeak;</span>
<span class="source-line-no">131</span><span id="line-131">    }</span>
<span class="source-line-no">132</span><span id="line-132"></span>
<span class="source-line-no">133</span><span id="line-133">    /**</span>
<span class="source-line-no">134</span><span id="line-134">     * Apply a collection of validations on a Word 97-2003 (binary format) document file provided:</span>
<span class="source-line-no">135</span><span id="line-135">     * &lt;ul&gt;</span>
<span class="source-line-no">136</span><span id="line-136">     * &lt;li&gt;Real Microsoft Word 97-2003 document file.&lt;/li&gt;</span>
<span class="source-line-no">137</span><span id="line-137">     * &lt;li&gt;No VBA Macro.&lt;br&gt;&lt;/li&gt;</span>
<span class="source-line-no">138</span><span id="line-138">     * &lt;li&gt;No embedded objects.&lt;/li&gt;</span>
<span class="source-line-no">139</span><span id="line-139">     * &lt;/ul&gt;</span>
<span class="source-line-no">140</span><span id="line-140">     *</span>
<span class="source-line-no">141</span><span id="line-141">     * @param wordFilePath Filename of the Word document file to check.</span>
<span class="source-line-no">142</span><span id="line-142">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">143</span><span id="line-143">     * @see "https://poi.apache.org/components/"</span>
<span class="source-line-no">144</span><span id="line-144">     * @see "https://poi.apache.org/components/document/"</span>
<span class="source-line-no">145</span><span id="line-145">     * @see "https://poi.apache.org/components/poifs/how-to.html"</span>
<span class="source-line-no">146</span><span id="line-146">     * @see "https://poi.apache.org/components/poifs/embeded.html"</span>
<span class="source-line-no">147</span><span id="line-147">     * @see "https://poi.apache.org/"</span>
<span class="source-line-no">148</span><span id="line-148">     * @see "https://mvnrepository.com/artifact/org.apache.poi/poi"</span>
<span class="source-line-no">149</span><span id="line-149">     */</span>
<span class="source-line-no">150</span><span id="line-150">    public static boolean isWord972003DocumentSafe(String wordFilePath) {</span>
<span class="source-line-no">151</span><span id="line-151">        boolean isSafe = false;</span>
<span class="source-line-no">152</span><span id="line-152">        try {</span>
<span class="source-line-no">153</span><span id="line-153">            File wordFile = new File(wordFilePath);</span>
<span class="source-line-no">154</span><span id="line-154">            if (wordFile.exists() &amp;&amp; wordFile.canRead() &amp;&amp; wordFile.isFile()) {</span>
<span class="source-line-no">155</span><span id="line-155">                //Step 1: Try to load the file, if its fail then it imply that is not a valid Word 97-2003 format file</span>
<span class="source-line-no">156</span><span id="line-156">                try (POIFSFileSystem fs = new POIFSFileSystem(wordFile)) {</span>
<span class="source-line-no">157</span><span id="line-157">                    //Step 2: Check if the document contains VBA macros, in our case is not allowed</span>
<span class="source-line-no">158</span><span id="line-158">                    VBAMacroReader macroReader = new VBAMacroReader(fs);</span>
<span class="source-line-no">159</span><span id="line-159">                    Map&lt;String, String&gt; macros = macroReader.readMacros();</span>
<span class="source-line-no">160</span><span id="line-160">                    if (macros == null || macros.isEmpty()) {</span>
<span class="source-line-no">161</span><span id="line-161">                        //Step 3: Check if the document contains any embedded objects, in our case is not allowed</span>
<span class="source-line-no">162</span><span id="line-162">                        //From POI documentation:</span>
<span class="source-line-no">163</span><span id="line-163">                        //Word normally stores embedded files in subdirectories of the ObjectPool directory, itself a subdirectory of the filesystem root.</span>
<span class="source-line-no">164</span><span id="line-164">                        //Typically, these subdirectories and named starting with an underscore, followed by 10 numbers.</span>
<span class="source-line-no">165</span><span id="line-165">                        final List&lt;String&gt; embeddedObjectFound = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">166</span><span id="line-166">                        DirectoryEntry root = fs.getRoot();</span>
<span class="source-line-no">167</span><span id="line-167">                        if (root.getEntryCount() &gt; 0) {</span>
<span class="source-line-no">168</span><span id="line-168">                            root.iterator().forEachRemaining(entry -&gt; {</span>
<span class="source-line-no">169</span><span id="line-169">                                if ("ObjectPool".equalsIgnoreCase(entry.getName()) &amp;&amp; entry instanceof DirectoryEntry) {</span>
<span class="source-line-no">170</span><span id="line-170">                                    DirectoryEntry objPoolDirectory = (DirectoryEntry) entry;</span>
<span class="source-line-no">171</span><span id="line-171">                                    if (objPoolDirectory.getEntryCount() &gt; 0) {</span>
<span class="source-line-no">172</span><span id="line-172">                                        objPoolDirectory.iterator().forEachRemaining(objPoolDirectoryEntry -&gt; {</span>
<span class="source-line-no">173</span><span id="line-173">                                            if (objPoolDirectoryEntry instanceof DirectoryEntry) {</span>
<span class="source-line-no">174</span><span id="line-174">                                                DirectoryEntry objPoolDirectoryEntrySubDirectoryEntry = (DirectoryEntry) objPoolDirectoryEntry;</span>
<span class="source-line-no">175</span><span id="line-175">                                                if (objPoolDirectoryEntrySubDirectoryEntry.getEntryCount() &gt; 0) {</span>
<span class="source-line-no">176</span><span id="line-176">                                                    objPoolDirectoryEntrySubDirectoryEntry.forEach(objPoolDirectoryEntrySubDirectoryEntryEntry -&gt; {</span>
<span class="source-line-no">177</span><span id="line-177">                                                        if (objPoolDirectoryEntrySubDirectoryEntryEntry.isDocumentEntry()) {</span>
<span class="source-line-no">178</span><span id="line-178">                                                            embeddedObjectFound.add(objPoolDirectoryEntrySubDirectoryEntryEntry.getName());</span>
<span class="source-line-no">179</span><span id="line-179">                                                        }</span>
<span class="source-line-no">180</span><span id="line-180">                                                    });</span>
<span class="source-line-no">181</span><span id="line-181">                                                }</span>
<span class="source-line-no">182</span><span id="line-182">                                            }</span>
<span class="source-line-no">183</span><span id="line-183">                                        });</span>
<span class="source-line-no">184</span><span id="line-184">                                    }</span>
<span class="source-line-no">185</span><span id="line-185">                                }</span>
<span class="source-line-no">186</span><span id="line-186">                            });</span>
<span class="source-line-no">187</span><span id="line-187">                        }</span>
<span class="source-line-no">188</span><span id="line-188">                        isSafe = embeddedObjectFound.isEmpty();</span>
<span class="source-line-no">189</span><span id="line-189">                    }</span>
<span class="source-line-no">190</span><span id="line-190">                }</span>
<span class="source-line-no">191</span><span id="line-191">            }</span>
<span class="source-line-no">192</span><span id="line-192">        } catch (Exception e) {</span>
<span class="source-line-no">193</span><span id="line-193">            isSafe = false;</span>
<span class="source-line-no">194</span><span id="line-194">        }</span>
<span class="source-line-no">195</span><span id="line-195">        return isSafe;</span>
<span class="source-line-no">196</span><span id="line-196">    }</span>
<span class="source-line-no">197</span><span id="line-197"></span>
<span class="source-line-no">198</span><span id="line-198">    /**</span>
<span class="source-line-no">199</span><span id="line-199">     * Ensure that an XML file does not contain any External Entity, DTD or XInclude instructions.</span>
<span class="source-line-no">200</span><span id="line-200">     *</span>
<span class="source-line-no">201</span><span id="line-201">     * @param xmlFilePath Filename of the XML file to check.</span>
<span class="source-line-no">202</span><span id="line-202">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">203</span><span id="line-203">     * @see "https://portswigger.net/web-security/xxe"</span>
<span class="source-line-no">204</span><span id="line-204">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java"</span>
<span class="source-line-no">205</span><span id="line-205">     * @see "https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-82F8C206-F2DF-4204-9544-F96155B1D258"</span>
<span class="source-line-no">206</span><span id="line-206">     * @see "https://www.w3.org/TR/xinclude-11/"</span>
<span class="source-line-no">207</span><span id="line-207">     * @see "https://en.wikipedia.org/wiki/XInclude"</span>
<span class="source-line-no">208</span><span id="line-208">     */</span>
<span class="source-line-no">209</span><span id="line-209">    public static boolean isXMLSafe(String xmlFilePath) {</span>
<span class="source-line-no">210</span><span id="line-210">        boolean isSafe = false;</span>
<span class="source-line-no">211</span><span id="line-211">        try {</span>
<span class="source-line-no">212</span><span id="line-212">            File xmlFile = new File(xmlFilePath);</span>
<span class="source-line-no">213</span><span id="line-213">            if (xmlFile.exists() &amp;&amp; xmlFile.canRead() &amp;&amp; xmlFile.isFile()) {</span>
<span class="source-line-no">214</span><span id="line-214">                //Step 1a: Verify that the XML file content does not contain any XInclude instructions</span>
<span class="source-line-no">215</span><span id="line-215">                boolean containXInclude = Files.readAllLines(xmlFile.toPath()).stream().anyMatch(line -&gt; line.toLowerCase(Locale.ROOT).contains(":include "));</span>
<span class="source-line-no">216</span><span id="line-216">                if (!containXInclude) {</span>
<span class="source-line-no">217</span><span id="line-217">                    //Step 1b: Parse the XML file, if an exception occur than it's imply that the XML specified is not a valid ones</span>
<span class="source-line-no">218</span><span id="line-218">                    //Create an XML document builder throwing Exception if a DOCTYPE instruction is present</span>
<span class="source-line-no">219</span><span id="line-219">                    DocumentBuilderFactory dbfInstance = DocumentBuilderFactory.newInstance();</span>
<span class="source-line-no">220</span><span id="line-220">                    dbfInstance.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</span>
<span class="source-line-no">221</span><span id="line-221">                    //Xerces 2 only</span>
<span class="source-line-no">222</span><span id="line-222">                    //dbfInstance.setFeature("http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl",true);</span>
<span class="source-line-no">223</span><span id="line-223">                    dbfInstance.setXIncludeAware(false);</span>
<span class="source-line-no">224</span><span id="line-224">                    DocumentBuilder builder = dbfInstance.newDocumentBuilder();</span>
<span class="source-line-no">225</span><span id="line-225">                    //Parse the document</span>
<span class="source-line-no">226</span><span id="line-226">                    Document doc = builder.parse(xmlFile);</span>
<span class="source-line-no">227</span><span id="line-227">                    isSafe = (doc != null &amp;&amp; doc.getDocumentElement() != null);</span>
<span class="source-line-no">228</span><span id="line-228">                }</span>
<span class="source-line-no">229</span><span id="line-229">            }</span>
<span class="source-line-no">230</span><span id="line-230">        } catch (Exception e) {</span>
<span class="source-line-no">231</span><span id="line-231">            isSafe = false;</span>
<span class="source-line-no">232</span><span id="line-232">        }</span>
<span class="source-line-no">233</span><span id="line-233">        return isSafe;</span>
<span class="source-line-no">234</span><span id="line-234">    }</span>
<span class="source-line-no">235</span><span id="line-235"></span>
<span class="source-line-no">236</span><span id="line-236"></span>
<span class="source-line-no">237</span><span id="line-237">    /**</span>
<span class="source-line-no">238</span><span id="line-238">     * Extract all URL links from a PDF file provided.&lt;br&gt;</span>
<span class="source-line-no">239</span><span id="line-239">     * This can be used to apply validation on a PDF against contained links.</span>
<span class="source-line-no">240</span><span id="line-240">     *</span>
<span class="source-line-no">241</span><span id="line-241">     * @param pdfFilePath pdfFilePath Filename of the PDF file to process.</span>
<span class="source-line-no">242</span><span id="line-242">     * @return A List of URL objects that is empty if no links is found.</span>
<span class="source-line-no">243</span><span id="line-243">     * @throws Exception If any error occurs during the processing of the PDF file.</span>
<span class="source-line-no">244</span><span id="line-244">     * @see "https://www.gushiciku.cn/pl/21KQ"</span>
<span class="source-line-no">245</span><span id="line-245">     * @see "https://pdfbox.apache.org/"</span>
<span class="source-line-no">246</span><span id="line-246">     * @see "https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox"</span>
<span class="source-line-no">247</span><span id="line-247">     */</span>
<span class="source-line-no">248</span><span id="line-248">    public static List&lt;URL&gt; extractAllPDFLinks(String pdfFilePath) throws Exception {</span>
<span class="source-line-no">249</span><span id="line-249">        final List&lt;URL&gt; links = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">250</span><span id="line-250">        File pdfFile = new File(pdfFilePath);</span>
<span class="source-line-no">251</span><span id="line-251">        try (PDDocument document = Loader.loadPDF(pdfFile)) {</span>
<span class="source-line-no">252</span><span id="line-252">            PDDocumentCatalog documentCatalog = document.getDocumentCatalog();</span>
<span class="source-line-no">253</span><span id="line-253">            AnnotationFilter actionURIAnnotationFilter = new AnnotationFilter() {</span>
<span class="source-line-no">254</span><span id="line-254">                @Override</span>
<span class="source-line-no">255</span><span id="line-255">                public boolean accept(PDAnnotation annotation) {</span>
<span class="source-line-no">256</span><span id="line-256">                    boolean keep = false;</span>
<span class="source-line-no">257</span><span id="line-257">                    if (annotation instanceof PDAnnotationLink) {</span>
<span class="source-line-no">258</span><span id="line-258">                        keep = (((PDAnnotationLink) annotation).getAction() instanceof PDActionURI);</span>
<span class="source-line-no">259</span><span id="line-259">                    }</span>
<span class="source-line-no">260</span><span id="line-260">                    return keep;</span>
<span class="source-line-no">261</span><span id="line-261">                }</span>
<span class="source-line-no">262</span><span id="line-262">            };</span>
<span class="source-line-no">263</span><span id="line-263">            documentCatalog.getPages().forEach(page -&gt; {</span>
<span class="source-line-no">264</span><span id="line-264">                try {</span>
<span class="source-line-no">265</span><span id="line-265">                    page.getAnnotations(actionURIAnnotationFilter).forEach(annotation -&gt; {</span>
<span class="source-line-no">266</span><span id="line-266">                        PDActionURI linkAnnotation = (PDActionURI) ((PDAnnotationLink) annotation).getAction();</span>
<span class="source-line-no">267</span><span id="line-267">                        try {</span>
<span class="source-line-no">268</span><span id="line-268">                            URL urlObj = new URL(linkAnnotation.getURI());</span>
<span class="source-line-no">269</span><span id="line-269">                            if (!links.contains(urlObj)) {</span>
<span class="source-line-no">270</span><span id="line-270">                                links.add(urlObj);</span>
<span class="source-line-no">271</span><span id="line-271">                            }</span>
<span class="source-line-no">272</span><span id="line-272">                        } catch (MalformedURLException e) {</span>
<span class="source-line-no">273</span><span id="line-273">                            throw new RuntimeException(e);</span>
<span class="source-line-no">274</span><span id="line-274">                        }</span>
<span class="source-line-no">275</span><span id="line-275">                    });</span>
<span class="source-line-no">276</span><span id="line-276">                } catch (Exception e) {</span>
<span class="source-line-no">277</span><span id="line-277">                    throw new RuntimeException(e);</span>
<span class="source-line-no">278</span><span id="line-278">                }</span>
<span class="source-line-no">279</span><span id="line-279">            });</span>
<span class="source-line-no">280</span><span id="line-280">        }</span>
<span class="source-line-no">281</span><span id="line-281">        return links;</span>
<span class="source-line-no">282</span><span id="line-282">    }</span>
<span class="source-line-no">283</span><span id="line-283"></span>
<span class="source-line-no">284</span><span id="line-284">    /**</span>
<span class="source-line-no">285</span><span id="line-285">     * Apply a collection of validations on a PDF file provided:</span>
<span class="source-line-no">286</span><span id="line-286">     * &lt;ul&gt;</span>
<span class="source-line-no">287</span><span id="line-287">     * &lt;li&gt;Real PDF file.&lt;/li&gt;</span>
<span class="source-line-no">288</span><span id="line-288">     * &lt;li&gt;No attachments.&lt;/li&gt;</span>
<span class="source-line-no">289</span><span id="line-289">     * &lt;li&gt;No Javascript code.&lt;/li&gt;</span>
<span class="source-line-no">290</span><span id="line-290">     * &lt;li&gt;No links using action of type URI/Launch/RemoteGoTo/ImportData.&lt;/li&gt;</span>
<span class="source-line-no">291</span><span id="line-291">     * &lt;/ul&gt;</span>
<span class="source-line-no">292</span><span id="line-292">     *</span>
<span class="source-line-no">293</span><span id="line-293">     * @param pdfFilePath Filename of the PDF file to check.</span>
<span class="source-line-no">294</span><span id="line-294">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">295</span><span id="line-295">     * @see "https://stackoverflow.com/a/36161267"</span>
<span class="source-line-no">296</span><span id="line-296">     * @see "https://www.gushiciku.cn/pl/21KQ"</span>
<span class="source-line-no">297</span><span id="line-297">     * @see "https://github.com/jonaslejon/malicious-pdf"</span>
<span class="source-line-no">298</span><span id="line-298">     * @see "https://pdfbox.apache.org/"</span>
<span class="source-line-no">299</span><span id="line-299">     * @see "https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox"</span>
<span class="source-line-no">300</span><span id="line-300">     */</span>
<span class="source-line-no">301</span><span id="line-301">    public static boolean isPDFSafe(String pdfFilePath) {</span>
<span class="source-line-no">302</span><span id="line-302">        boolean isSafe = false;</span>
<span class="source-line-no">303</span><span id="line-303">        try {</span>
<span class="source-line-no">304</span><span id="line-304">            File pdfFile = new File(pdfFilePath);</span>
<span class="source-line-no">305</span><span id="line-305">            if (pdfFile.exists() &amp;&amp; pdfFile.canRead() &amp;&amp; pdfFile.isFile()) {</span>
<span class="source-line-no">306</span><span id="line-306">                //Step 1: Try to load the file, if its fail then it imply that is not a valid PDF file</span>
<span class="source-line-no">307</span><span id="line-307">                try (PDDocument document = Loader.loadPDF(pdfFile)) {</span>
<span class="source-line-no">308</span><span id="line-308">                    //Step 2: Check if the file contains attached files, in our case is not allowed</span>
<span class="source-line-no">309</span><span id="line-309">                    PDDocumentCatalog documentCatalog = document.getDocumentCatalog();</span>
<span class="source-line-no">310</span><span id="line-310">                    PDDocumentNameDictionary namesDictionary = new PDDocumentNameDictionary(documentCatalog);</span>
<span class="source-line-no">311</span><span id="line-311">                    if (namesDictionary.getEmbeddedFiles() == null) {</span>
<span class="source-line-no">312</span><span id="line-312">                        //Step 3: Check if the file contains Javascript code, in our case is not allowed</span>
<span class="source-line-no">313</span><span id="line-313">                        if (namesDictionary.getJavaScript() == null) {</span>
<span class="source-line-no">314</span><span id="line-314">                            //Step 4: Check if the file contains links using action of type URI/Launch/RemoteGoTo/ImportData, in our case is not allowed</span>
<span class="source-line-no">315</span><span id="line-315">                            final List&lt;Integer&gt; notAllowedAnnotationCounterList = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">316</span><span id="line-316">                            AnnotationFilter notAllowedAnnotationFilter = new AnnotationFilter() {</span>
<span class="source-line-no">317</span><span id="line-317">                                @Override</span>
<span class="source-line-no">318</span><span id="line-318">                                public boolean accept(PDAnnotation annotation) {</span>
<span class="source-line-no">319</span><span id="line-319">                                    boolean keep = false;</span>
<span class="source-line-no">320</span><span id="line-320">                                    if (annotation instanceof PDAnnotationLink) {</span>
<span class="source-line-no">321</span><span id="line-321">                                        PDAnnotationLink link = (PDAnnotationLink) annotation;</span>
<span class="source-line-no">322</span><span id="line-322">                                        PDAction action = link.getAction();</span>
<span class="source-line-no">323</span><span id="line-323">                                        if ((action instanceof PDActionURI) || (action instanceof PDActionLaunch) || (action instanceof PDActionRemoteGoTo) || (action instanceof PDActionImportData)) {</span>
<span class="source-line-no">324</span><span id="line-324">                                            keep = true;</span>
<span class="source-line-no">325</span><span id="line-325">                                        }</span>
<span class="source-line-no">326</span><span id="line-326">                                    }</span>
<span class="source-line-no">327</span><span id="line-327">                                    return keep;</span>
<span class="source-line-no">328</span><span id="line-328">                                }</span>
<span class="source-line-no">329</span><span id="line-329">                            };</span>
<span class="source-line-no">330</span><span id="line-330">                            documentCatalog.getPages().forEach(page -&gt; {</span>
<span class="source-line-no">331</span><span id="line-331">                                try {</span>
<span class="source-line-no">332</span><span id="line-332">                                    notAllowedAnnotationCounterList.add(page.getAnnotations(notAllowedAnnotationFilter).size());</span>
<span class="source-line-no">333</span><span id="line-333">                                } catch (IOException e) {</span>
<span class="source-line-no">334</span><span id="line-334">                                    throw new RuntimeException(e);</span>
<span class="source-line-no">335</span><span id="line-335">                                }</span>
<span class="source-line-no">336</span><span id="line-336">                            });</span>
<span class="source-line-no">337</span><span id="line-337">                            if (notAllowedAnnotationCounterList.stream().reduce(0, Integer::sum) == 0) {</span>
<span class="source-line-no">338</span><span id="line-338">                                isSafe = true;</span>
<span class="source-line-no">339</span><span id="line-339">                            }</span>
<span class="source-line-no">340</span><span id="line-340">                        }</span>
<span class="source-line-no">341</span><span id="line-341">                    }</span>
<span class="source-line-no">342</span><span id="line-342">                }</span>
<span class="source-line-no">343</span><span id="line-343">            }</span>
<span class="source-line-no">344</span><span id="line-344">        } catch (Exception e) {</span>
<span class="source-line-no">345</span><span id="line-345">            isSafe = false;</span>
<span class="source-line-no">346</span><span id="line-346">        }</span>
<span class="source-line-no">347</span><span id="line-347">        return isSafe;</span>
<span class="source-line-no">348</span><span id="line-348">    }</span>
<span class="source-line-no">349</span><span id="line-349"></span>
<span class="source-line-no">350</span><span id="line-350">    /**</span>
<span class="source-line-no">351</span><span id="line-351">     * Remove as much as possible metadata from the provided PDF document object.</span>
<span class="source-line-no">352</span><span id="line-352">     *</span>
<span class="source-line-no">353</span><span id="line-353">     * @param document PDFBox PDF document object on which metadata must be removed.</span>
<span class="source-line-no">354</span><span id="line-354">     * @see "https://gist.github.com/righettod/d7e07443c43d393a39de741a0d920069"</span>
<span class="source-line-no">355</span><span id="line-355">     * @see "https://pdfbox.apache.org/"</span>
<span class="source-line-no">356</span><span id="line-356">     * @see "https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox"</span>
<span class="source-line-no">357</span><span id="line-357">     */</span>
<span class="source-line-no">358</span><span id="line-358">    public static void clearPDFMetadata(PDDocument document) {</span>
<span class="source-line-no">359</span><span id="line-359">        if (document != null) {</span>
<span class="source-line-no">360</span><span id="line-360">            PDDocumentInformation infoEmpty = new PDDocumentInformation();</span>
<span class="source-line-no">361</span><span id="line-361">            document.setDocumentInformation(infoEmpty);</span>
<span class="source-line-no">362</span><span id="line-362">            PDMetadata newMetadataEmpty = new PDMetadata(document);</span>
<span class="source-line-no">363</span><span id="line-363">            document.getDocumentCatalog().setMetadata(newMetadataEmpty);</span>
<span class="source-line-no">364</span><span id="line-364">        }</span>
<span class="source-line-no">365</span><span id="line-365">    }</span>
<span class="source-line-no">366</span><span id="line-366"></span>
<span class="source-line-no">367</span><span id="line-367"></span>
<span class="source-line-no">368</span><span id="line-368">    /**</span>
<span class="source-line-no">369</span><span id="line-369">     * Validate that the URL provided is really a relative URL.</span>
<span class="source-line-no">370</span><span id="line-370">     *</span>
<span class="source-line-no">371</span><span id="line-371">     * @param targetUrl URL to validate.</span>
<span class="source-line-no">372</span><span id="line-372">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">373</span><span id="line-373">     * @see "https://portswigger.net/web-security/ssrf"</span>
<span class="source-line-no">374</span><span id="line-374">     * @see "https://stackoverflow.com/q/6785442"</span>
<span class="source-line-no">375</span><span id="line-375">     */</span>
<span class="source-line-no">376</span><span id="line-376">    public static boolean isRelativeURL(String targetUrl) {</span>
<span class="source-line-no">377</span><span id="line-377">        boolean isValid = false;</span>
<span class="source-line-no">378</span><span id="line-378">        //Reject any URL encoded content and URL starting with a double slash</span>
<span class="source-line-no">379</span><span id="line-379">        //Reject any URL contains credentials or fragment to prevent potential bypasses</span>
<span class="source-line-no">380</span><span id="line-380">        String work = targetUrl;</span>
<span class="source-line-no">381</span><span id="line-381">        if (!work.contains("%") &amp;&amp; !work.contains("@") &amp;&amp; !work.contains("#") &amp;&amp; !work.startsWith("//")) {</span>
<span class="source-line-no">382</span><span id="line-382">            //Creation of a URL object must fail</span>
<span class="source-line-no">383</span><span id="line-383">            try {</span>
<span class="source-line-no">384</span><span id="line-384">                new URL(work);</span>
<span class="source-line-no">385</span><span id="line-385">                isValid = false;</span>
<span class="source-line-no">386</span><span id="line-386">            } catch (MalformedURLException mf) {</span>
<span class="source-line-no">387</span><span id="line-387">                //Last check to be sure (for prod usage compile the pattern one time)</span>
<span class="source-line-no">388</span><span id="line-388">                isValid = Pattern.compile("^/[a-z0-9]+", Pattern.CASE_INSENSITIVE).matcher(work).find();</span>
<span class="source-line-no">389</span><span id="line-389">            }</span>
<span class="source-line-no">390</span><span id="line-390">        }</span>
<span class="source-line-no">391</span><span id="line-391">        return isValid;</span>
<span class="source-line-no">392</span><span id="line-392">    }</span>
<span class="source-line-no">393</span><span id="line-393"></span>
<span class="source-line-no">394</span><span id="line-394">    /**</span>
<span class="source-line-no">395</span><span id="line-395">     * Apply a collection of validations on a ZIP file provided:</span>
<span class="source-line-no">396</span><span id="line-396">     * &lt;ul&gt;</span>
<span class="source-line-no">397</span><span id="line-397">     * &lt;li&gt;Real ZIP file.&lt;/li&gt;</span>
<span class="source-line-no">398</span><span id="line-398">     * &lt;li&gt;Contain less than a specified level of deepness.&lt;/li&gt;</span>
<span class="source-line-no">399</span><span id="line-399">     * &lt;li&gt;Do not contain Zip-Slip entry path.&lt;/li&gt;</span>
<span class="source-line-no">400</span><span id="line-400">     * &lt;/ul&gt;</span>
<span class="source-line-no">401</span><span id="line-401">     *</span>
<span class="source-line-no">402</span><span id="line-402">     * @param zipFilePath       Filename of the ZIP file to check.</span>
<span class="source-line-no">403</span><span id="line-403">     * @param maxLevelDeepness  Threshold of deepness above which a ZIP archive will be rejected.</span>
<span class="source-line-no">404</span><span id="line-404">     * @param rejectArchiveFile Flag to specify if presence of any archive entry will cause the rejection of the ZIP file.</span>
<span class="source-line-no">405</span><span id="line-405">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">406</span><span id="line-406">     * @see "https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5042"</span>
<span class="source-line-no">407</span><span id="line-407">     * @see "https://security.snyk.io/research/zip-slip-vulnerability"</span>
<span class="source-line-no">408</span><span id="line-408">     * @see "https://en.wikipedia.org/wiki/Zip_bomb"</span>
<span class="source-line-no">409</span><span id="line-409">     * @see "https://github.com/ptoomey3/evilarc"</span>
<span class="source-line-no">410</span><span id="line-410">     * @see "https://github.com/abdulfatir/ZipBomb"</span>
<span class="source-line-no">411</span><span id="line-411">     * @see "https://www.baeldung.com/cs/zip-bomb"</span>
<span class="source-line-no">412</span><span id="line-412">     * @see "https://thesecurityvault.com/attacks-with-zip-files-and-mitigations/"</span>
<span class="source-line-no">413</span><span id="line-413">     * @see "https://wiki.sei.cmu.edu/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream"</span>
<span class="source-line-no">414</span><span id="line-414">     */</span>
<span class="source-line-no">415</span><span id="line-415">    public static boolean isZIPSafe(String zipFilePath, int maxLevelDeepness, boolean rejectArchiveFile) {</span>
<span class="source-line-no">416</span><span id="line-416">        List&lt;String&gt; archiveExtensions = Arrays.asList("zip", "tar", "7z", "gz", "jar", "phar", "bz2", "tgz");</span>
<span class="source-line-no">417</span><span id="line-417">        boolean isSafe = false;</span>
<span class="source-line-no">418</span><span id="line-418">        try {</span>
<span class="source-line-no">419</span><span id="line-419">            File zipFile = new File(zipFilePath);</span>
<span class="source-line-no">420</span><span id="line-420">            if (zipFile.exists() &amp;&amp; zipFile.canRead() &amp;&amp; zipFile.isFile() &amp;&amp; maxLevelDeepness &gt; 0) {</span>
<span class="source-line-no">421</span><span id="line-421">                //Step 1: Try to load the file, if its fail then it imply that is not a valid ZIP file</span>
<span class="source-line-no">422</span><span id="line-422">                try (ZipFile zipArch = new ZipFile(zipFile)) {</span>
<span class="source-line-no">423</span><span id="line-423">                    //Step 2: Parse entries</span>
<span class="source-line-no">424</span><span id="line-424">                    long deepness = 0;</span>
<span class="source-line-no">425</span><span id="line-425">                    ZipEntry zipEntry;</span>
<span class="source-line-no">426</span><span id="line-426">                    String entryExtension;</span>
<span class="source-line-no">427</span><span id="line-427">                    String zipEntryName;</span>
<span class="source-line-no">428</span><span id="line-428">                    boolean validationsFailed = false;</span>
<span class="source-line-no">429</span><span id="line-429">                    Enumeration&lt;? extends ZipEntry&gt; entries = zipArch.entries();</span>
<span class="source-line-no">430</span><span id="line-430">                    while (entries.hasMoreElements()) {</span>
<span class="source-line-no">431</span><span id="line-431">                        zipEntry = entries.nextElement();</span>
<span class="source-line-no">432</span><span id="line-432">                        zipEntryName = zipEntry.getName();</span>
<span class="source-line-no">433</span><span id="line-433">                        entryExtension = zipEntryName.substring(zipEntryName.lastIndexOf(".") + 1).toLowerCase(Locale.ROOT).trim();</span>
<span class="source-line-no">434</span><span id="line-434">                        //Step 2a: Check if the current entry is an archive file</span>
<span class="source-line-no">435</span><span id="line-435">                        if (rejectArchiveFile &amp;&amp; archiveExtensions.contains(entryExtension)) {</span>
<span class="source-line-no">436</span><span id="line-436">                            validationsFailed = true;</span>
<span class="source-line-no">437</span><span id="line-437">                            break;</span>
<span class="source-line-no">438</span><span id="line-438">                        }</span>
<span class="source-line-no">439</span><span id="line-439">                        //Step 2b: Check that level of deepness is inferior to the threshold specified</span>
<span class="source-line-no">440</span><span id="line-440">                        if (zipEntryName.contains("/")) {</span>
<span class="source-line-no">441</span><span id="line-441">                            //Determine deepness by inspecting the entry name.</span>
<span class="source-line-no">442</span><span id="line-442">                            //Indeed, folder will be represented like this: folder/folder/folder/</span>
<span class="source-line-no">443</span><span id="line-443">                            //So we can count the number of "/" to identify the deepness of the entry</span>
<span class="source-line-no">444</span><span id="line-444">                            deepness = zipEntryName.chars().filter(ch -&gt; ch == '/').count();</span>
<span class="source-line-no">445</span><span id="line-445">                            if (deepness &gt; maxLevelDeepness) {</span>
<span class="source-line-no">446</span><span id="line-446">                                validationsFailed = true;</span>
<span class="source-line-no">447</span><span id="line-447">                                break;</span>
<span class="source-line-no">448</span><span id="line-448">                            }</span>
<span class="source-line-no">449</span><span id="line-449">                        }</span>
<span class="source-line-no">450</span><span id="line-450">                        //Step 2c: Check if any entries match pattern of zip slip payload</span>
<span class="source-line-no">451</span><span id="line-451">                        if (zipEntryName.contains("..\\") || zipEntryName.contains("../")) {</span>
<span class="source-line-no">452</span><span id="line-452">                            validationsFailed = true;</span>
<span class="source-line-no">453</span><span id="line-453">                            break;</span>
<span class="source-line-no">454</span><span id="line-454">                        }</span>
<span class="source-line-no">455</span><span id="line-455">                    }</span>
<span class="source-line-no">456</span><span id="line-456">                    if (!validationsFailed) {</span>
<span class="source-line-no">457</span><span id="line-457">                        isSafe = true;</span>
<span class="source-line-no">458</span><span id="line-458">                    }</span>
<span class="source-line-no">459</span><span id="line-459">                }</span>
<span class="source-line-no">460</span><span id="line-460">            }</span>
<span class="source-line-no">461</span><span id="line-461">        } catch (Exception e) {</span>
<span class="source-line-no">462</span><span id="line-462">            isSafe = false;</span>
<span class="source-line-no">463</span><span id="line-463">        }</span>
<span class="source-line-no">464</span><span id="line-464">        return isSafe;</span>
<span class="source-line-no">465</span><span id="line-465">    }</span>
<span class="source-line-no">466</span><span id="line-466"></span>
<span class="source-line-no">467</span><span id="line-467">    /**</span>
<span class="source-line-no">468</span><span id="line-468">     * Identify the mime type of the content specified (array of bytes).&lt;br&gt;</span>
<span class="source-line-no">469</span><span id="line-469">     * Note that it cannot be fully trusted (see the tweet '1595824709186519041' referenced), so, additional validations are required.</span>
<span class="source-line-no">470</span><span id="line-470">     *</span>
<span class="source-line-no">471</span><span id="line-471">     * @param content The content as an array of bytes.</span>
<span class="source-line-no">472</span><span id="line-472">     * @return The mime type in lower case or null if it cannot be identified.</span>
<span class="source-line-no">473</span><span id="line-473">     * @see "https://twitter.com/righettod/status/1595824709186519041"</span>
<span class="source-line-no">474</span><span id="line-474">     * @see "https://tika.apache.org/"</span>
<span class="source-line-no">475</span><span id="line-475">     * @see "https://mvnrepository.com/artifact/org.apache.tika/tika-core"</span>
<span class="source-line-no">476</span><span id="line-476">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"</span>
<span class="source-line-no">477</span><span id="line-477">     * @see "https://www.iana.org/assignments/media-types/media-types.xhtml"</span>
<span class="source-line-no">478</span><span id="line-478">     */</span>
<span class="source-line-no">479</span><span id="line-479">    public static String identifyMimeType(byte[] content) {</span>
<span class="source-line-no">480</span><span id="line-480">        String mimeType = null;</span>
<span class="source-line-no">481</span><span id="line-481">        if (content != null &amp;&amp; content.length &gt; 0) {</span>
<span class="source-line-no">482</span><span id="line-482">            Detector detector = new DefaultDetector(MimeTypes.getDefaultMimeTypes());</span>
<span class="source-line-no">483</span><span id="line-483">            Metadata metadata = new Metadata();</span>
<span class="source-line-no">484</span><span id="line-484">            try {</span>
<span class="source-line-no">485</span><span id="line-485">                try (TemporaryResources temporaryResources = new TemporaryResources(); TikaInputStream tikaInputStream = TikaInputStream.get(new ByteArrayInputStream(content), temporaryResources, metadata)) {</span>
<span class="source-line-no">486</span><span id="line-486">                    MediaType mt = detector.detect(tikaInputStream, metadata);</span>
<span class="source-line-no">487</span><span id="line-487">                    if (mt != null) {</span>
<span class="source-line-no">488</span><span id="line-488">                        mimeType = mt.toString().toLowerCase(Locale.ROOT);</span>
<span class="source-line-no">489</span><span id="line-489">                    }</span>
<span class="source-line-no">490</span><span id="line-490">                }</span>
<span class="source-line-no">491</span><span id="line-491">            } catch (IOException ioe) {</span>
<span class="source-line-no">492</span><span id="line-492">                mimeType = null;</span>
<span class="source-line-no">493</span><span id="line-493">            }</span>
<span class="source-line-no">494</span><span id="line-494">        }</span>
<span class="source-line-no">495</span><span id="line-495">        return mimeType;</span>
<span class="source-line-no">496</span><span id="line-496">    }</span>
<span class="source-line-no">497</span><span id="line-497"></span>
<span class="source-line-no">498</span><span id="line-498">    /**</span>
<span class="source-line-no">499</span><span id="line-499">     * Apply a collection of validations on a string expected to be an public IP address:</span>
<span class="source-line-no">500</span><span id="line-500">     * &lt;ul&gt;</span>
<span class="source-line-no">501</span><span id="line-501">     * &lt;li&gt;Is a valid IP v4 or v6 address.&lt;/li&gt;</span>
<span class="source-line-no">502</span><span id="line-502">     * &lt;li&gt;Is public from an Internet perspective.&lt;/li&gt;</span>
<span class="source-line-no">503</span><span id="line-503">     * &lt;/ul&gt;</span>
<span class="source-line-no">504</span><span id="line-504">     * &lt;br&gt;</span>
<span class="source-line-no">505</span><span id="line-505">     * &lt;b&gt;Note:&lt;/b&gt; I often see missing such validation in the value read from HTTP request headers like "X-Forwarded-For" or "Forwarded".</span>
<span class="source-line-no">506</span><span id="line-506">     * &lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">507</span><span id="line-507">     * &lt;b&gt;Note for IPv6:&lt;/b&gt; I used documentation found so it is really experimental!</span>
<span class="source-line-no">508</span><span id="line-508">     *</span>
<span class="source-line-no">509</span><span id="line-509">     * @param ip String expected to be a valid IP address.</span>
<span class="source-line-no">510</span><span id="line-510">     * @return True only if the string pass all validations.</span>
<span class="source-line-no">511</span><span id="line-511">     * @see "https://commons.apache.org/proper/commons-validator/"</span>
<span class="source-line-no">512</span><span id="line-512">     * @see "https://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/routines/InetAddressValidator.html"</span>
<span class="source-line-no">513</span><span id="line-513">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"</span>
<span class="source-line-no">514</span><span id="line-514">     * @see "https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_Orange_Tsai_Talk.pdf"</span>
<span class="source-line-no">515</span><span id="line-515">     * @see "https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf"</span>
<span class="source-line-no">516</span><span id="line-516">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For"</span>
<span class="source-line-no">517</span><span id="line-517">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded"</span>
<span class="source-line-no">518</span><span id="line-518">     * @see "https://ipcisco.com/lesson/ipv6-address/"</span>
<span class="source-line-no">519</span><span id="line-519">     * @see "https://www.juniper.net/documentation/us/en/software/junos/interfaces-security-devices/topics/topic-map/security-interface-ipv4-ipv6-protocol.html"</span>
<span class="source-line-no">520</span><span id="line-520">     * @see "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/InetAddress.html#getByName(java.lang.String)"</span>
<span class="source-line-no">521</span><span id="line-521">     * @see "https://www.arin.net/reference/research/statistics/address_filters/"</span>
<span class="source-line-no">522</span><span id="line-522">     * @see "https://en.wikipedia.org/wiki/Multicast_address"</span>
<span class="source-line-no">523</span><span id="line-523">     * @see "https://stackoverflow.com/a/5619409"</span>
<span class="source-line-no">524</span><span id="line-524">     * @see "https://www.ripe.net/media/documents/ipv6-address-types.pdf"</span>
<span class="source-line-no">525</span><span id="line-525">     * @see "https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xhtml"</span>
<span class="source-line-no">526</span><span id="line-526">     * @see "https://developer.android.com/reference/java/net/Inet6Address"</span>
<span class="source-line-no">527</span><span id="line-527">     * @see "https://en.wikipedia.org/wiki/Unique_local_address"</span>
<span class="source-line-no">528</span><span id="line-528">     */</span>
<span class="source-line-no">529</span><span id="line-529">    public static boolean isPublicIPAddress(String ip) {</span>
<span class="source-line-no">530</span><span id="line-530">        boolean isValid = false;</span>
<span class="source-line-no">531</span><span id="line-531">        try {</span>
<span class="source-line-no">532</span><span id="line-532">            //Quick validation on the string itself based on characters used to compose an IP v4/v6 address</span>
<span class="source-line-no">533</span><span id="line-533">            if (Pattern.matches("[0-9a-fA-F:.]+", ip)) {</span>
<span class="source-line-no">534</span><span id="line-534">                //If OK then use the dedicated InetAddressValidator from Apache Commons Validator</span>
<span class="source-line-no">535</span><span id="line-535">                if (InetAddressValidator.getInstance().isValid(ip)) {</span>
<span class="source-line-no">536</span><span id="line-536">                    //If OK then validate that is an public IP address</span>
<span class="source-line-no">537</span><span id="line-537">                    //From Javadoc for "InetAddress.getByName": If a literal IP address is supplied, only the validity of the address format is checked.</span>
<span class="source-line-no">538</span><span id="line-538">                    InetAddress addr = InetAddress.getByName(ip);</span>
<span class="source-line-no">539</span><span id="line-539">                    isValid = (!addr.isAnyLocalAddress() &amp;&amp; !addr.isLinkLocalAddress() &amp;&amp; !addr.isLoopbackAddress() &amp;&amp; !addr.isMulticastAddress() &amp;&amp; !addr.isSiteLocalAddress());</span>
<span class="source-line-no">540</span><span id="line-540">                    //If OK and the IP is an V6 one then make additional validation because the built-in Java API will let pass some V6 IP</span>
<span class="source-line-no">541</span><span id="line-541">                    //For the prefix map, the start of the key indicates if the value is a regex or a string</span>
<span class="source-line-no">542</span><span id="line-542">                    if (isValid &amp;&amp; (addr instanceof Inet6Address)) {</span>
<span class="source-line-no">543</span><span id="line-543">                        Map&lt;String, String&gt; prefixes = new HashMap&lt;&gt;();</span>
<span class="source-line-no">544</span><span id="line-544">                        prefixes.put("REGEX_LOOPBACK", "^(0|:)+1$");</span>
<span class="source-line-no">545</span><span id="line-545">                        prefixes.put("REGEX_UNIQUE-LOCAL-ADDRESSES", "^f(c|d)[a-f0-9]{2}:.*$");</span>
<span class="source-line-no">546</span><span id="line-546">                        prefixes.put("STRING_LINK-LOCAL-ADDRESSES", "fe80:");</span>
<span class="source-line-no">547</span><span id="line-547">                        prefixes.put("REGEX_TEREDO", "^2001:[0]*:.*$");</span>
<span class="source-line-no">548</span><span id="line-548">                        prefixes.put("REGEX_BENCHMARKING", "^2001:[0]*2:.*$");</span>
<span class="source-line-no">549</span><span id="line-549">                        prefixes.put("REGEX_ORCHID", "^2001:[0]*10:.*$");</span>
<span class="source-line-no">550</span><span id="line-550">                        prefixes.put("STRING_DOCUMENTATION", "2001:db8:");</span>
<span class="source-line-no">551</span><span id="line-551">                        prefixes.put("STRING_GLOBAL-UNICAST", "2000:");</span>
<span class="source-line-no">552</span><span id="line-552">                        prefixes.put("REGEX_MULTICAST", "^ff[0-9]{2}:.*$");</span>
<span class="source-line-no">553</span><span id="line-553">                        final List&lt;Boolean&gt; results = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">554</span><span id="line-554">                        final String ipLower = ip.trim().toLowerCase(Locale.ROOT);</span>
<span class="source-line-no">555</span><span id="line-555">                        prefixes.forEach((addressType, expr) -&gt; {</span>
<span class="source-line-no">556</span><span id="line-556">                            String exprLower = expr.trim().toLowerCase();</span>
<span class="source-line-no">557</span><span id="line-557">                            if (addressType.startsWith("STRING_")) {</span>
<span class="source-line-no">558</span><span id="line-558">                                results.add(ipLower.startsWith(exprLower));</span>
<span class="source-line-no">559</span><span id="line-559">                            } else {</span>
<span class="source-line-no">560</span><span id="line-560">                                results.add(Pattern.matches(exprLower, ipLower));</span>
<span class="source-line-no">561</span><span id="line-561">                            }</span>
<span class="source-line-no">562</span><span id="line-562">                        });</span>
<span class="source-line-no">563</span><span id="line-563">                        isValid = ((results.size() == prefixes.size()) &amp;&amp; !results.contains(Boolean.TRUE));</span>
<span class="source-line-no">564</span><span id="line-564">                    }</span>
<span class="source-line-no">565</span><span id="line-565">                }</span>
<span class="source-line-no">566</span><span id="line-566">            }</span>
<span class="source-line-no">567</span><span id="line-567">        } catch (Exception e) {</span>
<span class="source-line-no">568</span><span id="line-568">            isValid = false;</span>
<span class="source-line-no">569</span><span id="line-569">        }</span>
<span class="source-line-no">570</span><span id="line-570">        return isValid;</span>
<span class="source-line-no">571</span><span id="line-571">    }</span>
<span class="source-line-no">572</span><span id="line-572"></span>
<span class="source-line-no">573</span><span id="line-573">    /**</span>
<span class="source-line-no">574</span><span id="line-574">     * Compute a SHA256 hash from an input composed of a collection of strings.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">575</span><span id="line-575">     * This method take care to build the source string in a way to prevent this source string to be prone to abuse targeting the different parts composing it.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">576</span><span id="line-576">     * &lt;p&gt;</span>
<span class="source-line-no">577</span><span id="line-577">     * Example of possible abuse without precautions applied during the hash calculation logic:&lt;br&gt;</span>
<span class="source-line-no">578</span><span id="line-578">     * Hash of &lt;code&gt;SHA256("Hello", "My", "World!!!")&lt;/code&gt; will be equals to the hash of &lt;code&gt;SHA256("Hell", "oMyW", "orld!!!")&lt;/code&gt;.&lt;br&gt;</span>
<span class="source-line-no">579</span><span id="line-579">     * &lt;/p&gt;</span>
<span class="source-line-no">580</span><span id="line-580">     * This method ensure that both hash above will be different.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">581</span><span id="line-581">     *</span>
<span class="source-line-no">582</span><span id="line-582">     * &lt;b&gt;Note:&lt;/b&gt; The character &lt;code&gt;|&lt;/code&gt; is used, as separator, of every parts so a part is not allowed to contains this character.</span>
<span class="source-line-no">583</span><span id="line-583">     *</span>
<span class="source-line-no">584</span><span id="line-584">     * @param parts Ordered list of strings to use to build the input string for which the hash must be computed on. No null value is accepted on object composing the collection.</span>
<span class="source-line-no">585</span><span id="line-585">     * @return The hash, as an array of bytes, to allow caller to convert it to the final representation wanted (HEX, Base64, etc.). If the collection passed is null or empty then the method return null.</span>
<span class="source-line-no">586</span><span id="line-586">     * @throws Exception If any exception occurs</span>
<span class="source-line-no">587</span><span id="line-587">     * @see "https://github.com/righettod/code-snippets-security-utils/issues/16"</span>
<span class="source-line-no">588</span><span id="line-588">     * @see "https://pentesterlab.com/badges/codereview"</span>
<span class="source-line-no">589</span><span id="line-589">     * @see "https://blog.trailofbits.com/2024/08/21/yolo-is-not-a-valid-hash-construction/"</span>
<span class="source-line-no">590</span><span id="line-590">     * @see "https://www.nist.gov/publications/sha-3-derived-functions-cshake-kmac-tuplehash-and-parallelhash"</span>
<span class="source-line-no">591</span><span id="line-591">     */</span>
<span class="source-line-no">592</span><span id="line-592">    public static byte[] computeHashNoProneToAbuseOnParts(List&lt;String&gt; parts) throws Exception {</span>
<span class="source-line-no">593</span><span id="line-593">        byte[] hash = null;</span>
<span class="source-line-no">594</span><span id="line-594">        String separator = "|";</span>
<span class="source-line-no">595</span><span id="line-595">        if (parts != null &amp;&amp; !parts.isEmpty()) {</span>
<span class="source-line-no">596</span><span id="line-596">            //Ensure that not part is null</span>
<span class="source-line-no">597</span><span id="line-597">            if (parts.stream().anyMatch(Objects::isNull)) {</span>
<span class="source-line-no">598</span><span id="line-598">                throw new IllegalArgumentException("No part must be null!");</span>
<span class="source-line-no">599</span><span id="line-599">            }</span>
<span class="source-line-no">600</span><span id="line-600">            //Ensure that the separator is absent from every part</span>
<span class="source-line-no">601</span><span id="line-601">            if (parts.stream().anyMatch(part -&gt; part.contains(separator))) {</span>
<span class="source-line-no">602</span><span id="line-602">                throw new IllegalArgumentException(String.format("The character '%s', used as parts separator, must be absent from every parts!", separator));</span>
<span class="source-line-no">603</span><span id="line-603">            }</span>
<span class="source-line-no">604</span><span id="line-604">            MessageDigest digest = MessageDigest.getInstance("SHA-256");</span>
<span class="source-line-no">605</span><span id="line-605">            final StringBuilder buffer = new StringBuilder(separator);</span>
<span class="source-line-no">606</span><span id="line-606">            parts.forEach(p -&gt; {</span>
<span class="source-line-no">607</span><span id="line-607">                buffer.append(p).append(separator);</span>
<span class="source-line-no">608</span><span id="line-608">            });</span>
<span class="source-line-no">609</span><span id="line-609">            hash = digest.digest(buffer.toString().getBytes(StandardCharsets.UTF_8));</span>
<span class="source-line-no">610</span><span id="line-610">        }</span>
<span class="source-line-no">611</span><span id="line-611">        return hash;</span>
<span class="source-line-no">612</span><span id="line-612">    }</span>
<span class="source-line-no">613</span><span id="line-613"></span>
<span class="source-line-no">614</span><span id="line-614">    /**</span>
<span class="source-line-no">615</span><span id="line-615">     * Ensure that an XML file only uses DTD/XSD references (called System Identifier) present in the allowed list provided.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">616</span><span id="line-616">     * The code is based on the validation implemented into the OpenJDK 21, by the class &lt;b&gt;&lt;a href="https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.prefs/share/classes/java/util/prefs/XmlSupport.java"&gt;java.util.prefs.XmlSupport&lt;/a&gt;&lt;/b&gt;, in the method &lt;b&gt;&lt;a href="https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.prefs/share/classes/java/util/prefs/XmlSupport.java#L240"&gt;loadPrefsDoc()&lt;/a&gt;&lt;/b&gt;.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">617</span><span id="line-617">     * The method also ensure that no Public Identifier is used to prevent potential bypasses of the validations.</span>
<span class="source-line-no">618</span><span id="line-618">     *</span>
<span class="source-line-no">619</span><span id="line-619">     * @param xmlFilePath              Filename of the XML file to check.</span>
<span class="source-line-no">620</span><span id="line-620">     * @param allowedSystemIdentifiers List of URL allowed for System Identifier specified for any XSD/DTD references.</span>
<span class="source-line-no">621</span><span id="line-621">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">622</span><span id="line-622">     * @see "https://www.w3schools.com/xml/prop_documenttype_systemid.asp"</span>
<span class="source-line-no">623</span><span id="line-623">     * @see "https://www.ibm.com/docs/en/integration-bus/9.0.0?topic=doctypedecl-xml-systemid"</span>
<span class="source-line-no">624</span><span id="line-624">     * @see "https://www.liquid-technologies.com/Reference/Glossary/XML_DocType.html"</span>
<span class="source-line-no">625</span><span id="line-625">     * @see "https://www.xml.com/pub/98/08/xmlqna0.html"</span>
<span class="source-line-no">626</span><span id="line-626">     * @see "https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.prefs/share/classes/java/util/prefs/XmlSupport.java#L397"</span>
<span class="source-line-no">627</span><span id="line-627">     * @see "https://en.wikipedia.org/wiki/Formal_Public_Identifier"</span>
<span class="source-line-no">628</span><span id="line-628">     */</span>
<span class="source-line-no">629</span><span id="line-629">    public static boolean isXMLOnlyUseAllowedXSDorDTD(String xmlFilePath, final List&lt;String&gt; allowedSystemIdentifiers) {</span>
<span class="source-line-no">630</span><span id="line-630">        boolean isSafe = false;</span>
<span class="source-line-no">631</span><span id="line-631">        final String errorTemplate = "Non allowed %s ID detected!";</span>
<span class="source-line-no">632</span><span id="line-632">        final String emptyFakeDTD = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!ELEMENT dummy EMPTY&gt;";</span>
<span class="source-line-no">633</span><span id="line-633">        final String emptyFakeXSD = "&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"&gt; &lt;xs:element name=\"dummy\"/&gt;&lt;/xs:schema&gt;";</span>
<span class="source-line-no">634</span><span id="line-634"></span>
<span class="source-line-no">635</span><span id="line-635">        if (allowedSystemIdentifiers == null || allowedSystemIdentifiers.isEmpty()) {</span>
<span class="source-line-no">636</span><span id="line-636">            throw new IllegalArgumentException("At least one SID must be specified!");</span>
<span class="source-line-no">637</span><span id="line-637">        }</span>
<span class="source-line-no">638</span><span id="line-638">        File xmlFile = new File(xmlFilePath);</span>
<span class="source-line-no">639</span><span id="line-639">        if (xmlFile.exists() &amp;&amp; xmlFile.canRead() &amp;&amp; xmlFile.isFile()) {</span>
<span class="source-line-no">640</span><span id="line-640">            try {</span>
<span class="source-line-no">641</span><span id="line-641">                EntityResolver resolverValidator = (publicId, systemId) -&gt; {</span>
<span class="source-line-no">642</span><span id="line-642">                    if (publicId != null) {</span>
<span class="source-line-no">643</span><span id="line-643">                        throw new SAXException(String.format(errorTemplate, "PUBLIC"));</span>
<span class="source-line-no">644</span><span id="line-644">                    }</span>
<span class="source-line-no">645</span><span id="line-645">                    if (!allowedSystemIdentifiers.contains(systemId)) {</span>
<span class="source-line-no">646</span><span id="line-646">                        throw new SAXException(String.format(errorTemplate, "SYSTEM"));</span>
<span class="source-line-no">647</span><span id="line-647">                    }</span>
<span class="source-line-no">648</span><span id="line-648">                    //If it is OK then return a empty DTD/XSD</span>
<span class="source-line-no">649</span><span id="line-649">                    return new InputSource(new StringReader(systemId.toLowerCase().endsWith(".dtd") ? emptyFakeDTD : emptyFakeXSD));</span>
<span class="source-line-no">650</span><span id="line-650">                };</span>
<span class="source-line-no">651</span><span id="line-651">                DocumentBuilderFactory dbfInstance = DocumentBuilderFactory.newInstance();</span>
<span class="source-line-no">652</span><span id="line-652">                dbfInstance.setIgnoringElementContentWhitespace(true);</span>
<span class="source-line-no">653</span><span id="line-653">                dbfInstance.setXIncludeAware(false);</span>
<span class="source-line-no">654</span><span id="line-654">                dbfInstance.setValidating(false);</span>
<span class="source-line-no">655</span><span id="line-655">                dbfInstance.setCoalescing(true);</span>
<span class="source-line-no">656</span><span id="line-656">                dbfInstance.setIgnoringComments(false);</span>
<span class="source-line-no">657</span><span id="line-657">                DocumentBuilder builder = dbfInstance.newDocumentBuilder();</span>
<span class="source-line-no">658</span><span id="line-658">                builder.setEntityResolver(resolverValidator);</span>
<span class="source-line-no">659</span><span id="line-659">                Document doc = builder.parse(xmlFile);</span>
<span class="source-line-no">660</span><span id="line-660">                isSafe = (doc != null);</span>
<span class="source-line-no">661</span><span id="line-661">            } catch (SAXException | IOException | ParserConfigurationException e) {</span>
<span class="source-line-no">662</span><span id="line-662">                isSafe = false;</span>
<span class="source-line-no">663</span><span id="line-663">            }</span>
<span class="source-line-no">664</span><span id="line-664">        }</span>
<span class="source-line-no">665</span><span id="line-665"></span>
<span class="source-line-no">666</span><span id="line-666">        return isSafe;</span>
<span class="source-line-no">667</span><span id="line-667">    }</span>
<span class="source-line-no">668</span><span id="line-668"></span>
<span class="source-line-no">669</span><span id="line-669">    /**</span>
<span class="source-line-no">670</span><span id="line-670">     * Apply a collection of validations on a EXCEL CSV file provided (file was expected to be opened in Microsoft EXCEL):</span>
<span class="source-line-no">671</span><span id="line-671">     * &lt;ul&gt;</span>
<span class="source-line-no">672</span><span id="line-672">     * &lt;li&gt;Real CSV file.&lt;/li&gt;</span>
<span class="source-line-no">673</span><span id="line-673">     * &lt;li&gt;Do not contains any payload related to a CSV injections.&lt;/li&gt;</span>
<span class="source-line-no">674</span><span id="line-674">     * &lt;/ul&gt;</span>
<span class="source-line-no">675</span><span id="line-675">     * Ensure that, if Apache Commons CSV does not find any record then, the file will be considered as NOT safe (prevent potential bypasses).&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">676</span><span id="line-676">     * &lt;b&gt;Note:&lt;/b&gt; Record delimiter used is the &lt;code&gt;,&lt;/code&gt; (comma) character. See the Apache Commons CSV reference provided for EXCEL.&lt;br&gt;</span>
<span class="source-line-no">677</span><span id="line-677">     *</span>
<span class="source-line-no">678</span><span id="line-678">     * @param csvFilePath Filename of the CSV file to check.</span>
<span class="source-line-no">679</span><span id="line-679">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">680</span><span id="line-680">     * @see "https://commons.apache.org/proper/commons-csv/"</span>
<span class="source-line-no">681</span><span id="line-681">     * @see "https://commons.apache.org/proper/commons-csv/apidocs/org/apache/commons/csv/CSVFormat.html#EXCEL"</span>
<span class="source-line-no">682</span><span id="line-682">     * @see "https://www.we45.com/post/your-excel-sheets-are-not-safe-heres-how-to-beat-csv-injection"</span>
<span class="source-line-no">683</span><span id="line-683">     * @see "https://www.whiteoaksecurity.com/blog/2020-4-23-csv-injection-whats-the-risk/"</span>
<span class="source-line-no">684</span><span id="line-684">     * @see "https://book.hacktricks.xyz/pentesting-web/formula-csv-doc-latex-ghostscript-injection"</span>
<span class="source-line-no">685</span><span id="line-685">     * @see "https://owasp.org/www-community/attacks/CSV_Injection"</span>
<span class="source-line-no">686</span><span id="line-686">     * @see "https://payatu.com/blog/csv-injection-basic-to-exploit/"</span>
<span class="source-line-no">687</span><span id="line-687">     * @see "https://cwe.mitre.org/data/definitions/1236.html"</span>
<span class="source-line-no">688</span><span id="line-688">     */</span>
<span class="source-line-no">689</span><span id="line-689">    public static boolean isExcelCSVSafe(String csvFilePath) {</span>
<span class="source-line-no">690</span><span id="line-690">        boolean isSafe;</span>
<span class="source-line-no">691</span><span id="line-691">        final AtomicInteger recordCount = new AtomicInteger();</span>
<span class="source-line-no">692</span><span id="line-692">        final List&lt;Character&gt; payloadDetectionCharacters = List.of('=', '+', '@', '-', '\r', '\t');</span>
<span class="source-line-no">693</span><span id="line-693"></span>
<span class="source-line-no">694</span><span id="line-694">        try {</span>
<span class="source-line-no">695</span><span id="line-695">            final List&lt;String&gt; payloadsIdentified = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">696</span><span id="line-696">            try (Reader in = new FileReader(csvFilePath)) {</span>
<span class="source-line-no">697</span><span id="line-697">                Iterable&lt;CSVRecord&gt; records = CSVFormat.EXCEL.parse(in);</span>
<span class="source-line-no">698</span><span id="line-698">                records.forEach(record -&gt; {</span>
<span class="source-line-no">699</span><span id="line-699">                    record.forEach(recordValue -&gt; {</span>
<span class="source-line-no">700</span><span id="line-700">                        if (recordValue != null &amp;&amp; !recordValue.trim().isEmpty() &amp;&amp; payloadDetectionCharacters.contains(recordValue.trim().charAt(0))) {</span>
<span class="source-line-no">701</span><span id="line-701">                            payloadsIdentified.add(recordValue);</span>
<span class="source-line-no">702</span><span id="line-702">                        }</span>
<span class="source-line-no">703</span><span id="line-703">                        recordCount.getAndIncrement();</span>
<span class="source-line-no">704</span><span id="line-704">                    });</span>
<span class="source-line-no">705</span><span id="line-705">                });</span>
<span class="source-line-no">706</span><span id="line-706">            }</span>
<span class="source-line-no">707</span><span id="line-707">            isSafe = (payloadsIdentified.isEmpty() &amp;&amp; recordCount.get() &gt; 0);</span>
<span class="source-line-no">708</span><span id="line-708">        } catch (Exception e) {</span>
<span class="source-line-no">709</span><span id="line-709">            isSafe = false;</span>
<span class="source-line-no">710</span><span id="line-710">        }</span>
<span class="source-line-no">711</span><span id="line-711"></span>
<span class="source-line-no">712</span><span id="line-712">        return isSafe;</span>
<span class="source-line-no">713</span><span id="line-713">    }</span>
<span class="source-line-no">714</span><span id="line-714"></span>
<span class="source-line-no">715</span><span id="line-715">    /**</span>
<span class="source-line-no">716</span><span id="line-716">     * Provide a way to add an integrity marker (&lt;a href="https://en.wikipedia.org/wiki/HMAC"&gt;HMAC&lt;/a&gt;) to a serialized object serialized using the &lt;a href="https://www.baeldung.com/java-serialization"&gt;java native system&lt;/a&gt; (binary).&lt;br&gt;</span>
<span class="source-line-no">717</span><span id="line-717">     * The goal is to provide &lt;b&gt;a temporary workaround&lt;/b&gt; to try to prevent deserialization attacks and give time to move to a text-based serialization approach.</span>
<span class="source-line-no">718</span><span id="line-718">     *</span>
<span class="source-line-no">719</span><span id="line-719">     * @param processingMode Define the mode of processing i.e. protect or validate. ({@link eu.righettod.ProcessingMode})</span>
<span class="source-line-no">720</span><span id="line-720">     * @param input          When the processing mode is "protect" than the expected input (string) is a java serialized object encoded in Base64 otherwise (processing mode is "validate") expected input is the output of this method when the "protect" mode was used.</span>
<span class="source-line-no">721</span><span id="line-721">     * @param secret         Secret to use to compute the SHA256 HMAC.</span>
<span class="source-line-no">722</span><span id="line-722">     * @return A map with the following keys: &lt;ul&gt;&lt;li&gt;&lt;b&gt;PROCESSING_MODE&lt;/b&gt;: Processing mode used to compute the result.&lt;/li&gt;&lt;li&gt;&lt;b&gt;STATUS&lt;/b&gt;: A boolean indicating if the processing was successful or not.&lt;/li&gt;&lt;li&gt;&lt;b&gt;RESULT&lt;/b&gt;: Always contains a string representing the protected serialized object in the format &lt;code&gt;[SERIALIZED_OBJECT_BASE64_ENCODED]:[SERIALIZED_OBJECT_HMAC_BASE64_ENCODED]&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;</span>
<span class="source-line-no">723</span><span id="line-723">     * @throws Exception If any exception occurs.</span>
<span class="source-line-no">724</span><span id="line-724">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html"</span>
<span class="source-line-no">725</span><span id="line-725">     * @see "https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization"</span>
<span class="source-line-no">726</span><span id="line-726">     * @see "https://portswigger.net/web-security/deserialization"</span>
<span class="source-line-no">727</span><span id="line-727">     * @see "https://www.baeldung.com/java-serialization-approaches"</span>
<span class="source-line-no">728</span><span id="line-728">     * @see "https://www.baeldung.com/java-serialization"</span>
<span class="source-line-no">729</span><span id="line-729">     * @see "https://cryptobook.nakov.com/mac-and-key-derivation/hmac-and-key-derivation"</span>
<span class="source-line-no">730</span><span id="line-730">     * @see "https://en.wikipedia.org/wiki/HMAC"</span>
<span class="source-line-no">731</span><span id="line-731">     * @see "https://smattme.com/posts/how-to-generate-hmac-signature-in-java/"</span>
<span class="source-line-no">732</span><span id="line-732">     */</span>
<span class="source-line-no">733</span><span id="line-733">    public static Map&lt;String, Object&gt; ensureSerializedObjectIntegrity(ProcessingMode processingMode, String input, byte[] secret) throws Exception {</span>
<span class="source-line-no">734</span><span id="line-734">        Map&lt;String, Object&gt; results;</span>
<span class="source-line-no">735</span><span id="line-735">        String resultFormatTemplate = "%s:%s";</span>
<span class="source-line-no">736</span><span id="line-736">        //Verify input provided to be consistent</span>
<span class="source-line-no">737</span><span id="line-737">        if (processingMode == null) {</span>
<span class="source-line-no">738</span><span id="line-738">            throw new IllegalArgumentException("The processing mode is mandatory!");</span>
<span class="source-line-no">739</span><span id="line-739">        }</span>
<span class="source-line-no">740</span><span id="line-740">        if (input == null || input.trim().isEmpty()) {</span>
<span class="source-line-no">741</span><span id="line-741">            throw new IllegalArgumentException("Input data is mandatory!");</span>
<span class="source-line-no">742</span><span id="line-742">        }</span>
<span class="source-line-no">743</span><span id="line-743">        if (secret == null || secret.length == 0) {</span>
<span class="source-line-no">744</span><span id="line-744">            throw new IllegalArgumentException("The HMAC secret is mandatory!");</span>
<span class="source-line-no">745</span><span id="line-745">        }</span>
<span class="source-line-no">746</span><span id="line-746">        if (processingMode.equals(ProcessingMode.VALIDATE) &amp;&amp; input.split(":").length != 2) {</span>
<span class="source-line-no">747</span><span id="line-747">            throw new IllegalArgumentException("Input data provided is invalid for the processing mode specified!");</span>
<span class="source-line-no">748</span><span id="line-748">        }</span>
<span class="source-line-no">749</span><span id="line-749">        //Processing</span>
<span class="source-line-no">750</span><span id="line-750">        Base64.Decoder b64Decoder = Base64.getDecoder();</span>
<span class="source-line-no">751</span><span id="line-751">        Base64.Encoder b64Encoder = Base64.getEncoder();</span>
<span class="source-line-no">752</span><span id="line-752">        String hmacAlgorithm = "HmacSHA256";</span>
<span class="source-line-no">753</span><span id="line-753">        Mac mac = Mac.getInstance(hmacAlgorithm);</span>
<span class="source-line-no">754</span><span id="line-754">        SecretKeySpec key = new SecretKeySpec(secret, hmacAlgorithm);</span>
<span class="source-line-no">755</span><span id="line-755">        mac.init(key);</span>
<span class="source-line-no">756</span><span id="line-756">        results = new HashMap&lt;&gt;();</span>
<span class="source-line-no">757</span><span id="line-757">        results.put("PROCESSING_MODE", processingMode.toString());</span>
<span class="source-line-no">758</span><span id="line-758">        switch (processingMode) {</span>
<span class="source-line-no">759</span><span id="line-759">            case PROTECT -&gt; {</span>
<span class="source-line-no">760</span><span id="line-760">                byte[] objectBytes = b64Decoder.decode(input);</span>
<span class="source-line-no">761</span><span id="line-761">                byte[] hmac = mac.doFinal(objectBytes);</span>
<span class="source-line-no">762</span><span id="line-762">                String encodedHmac = b64Encoder.encodeToString(hmac);</span>
<span class="source-line-no">763</span><span id="line-763">                results.put("STATUS", Boolean.TRUE);</span>
<span class="source-line-no">764</span><span id="line-764">                results.put("RESULT", String.format(resultFormatTemplate, input, encodedHmac));</span>
<span class="source-line-no">765</span><span id="line-765">            }</span>
<span class="source-line-no">766</span><span id="line-766">            case VALIDATE -&gt; {</span>
<span class="source-line-no">767</span><span id="line-767">                String[] parts = input.split(":");</span>
<span class="source-line-no">768</span><span id="line-768">                byte[] objectBytes = b64Decoder.decode(parts[0].trim());</span>
<span class="source-line-no">769</span><span id="line-769">                byte[] hmacProvided = b64Decoder.decode(parts[1].trim());</span>
<span class="source-line-no">770</span><span id="line-770">                byte[] hmacComputed = mac.doFinal(objectBytes);</span>
<span class="source-line-no">771</span><span id="line-771">                String encodedHmacComputed = b64Encoder.encodeToString(hmacComputed);</span>
<span class="source-line-no">772</span><span id="line-772">                Boolean hmacIsValid = Arrays.equals(hmacProvided, hmacComputed);</span>
<span class="source-line-no">773</span><span id="line-773">                results.put("STATUS", hmacIsValid);</span>
<span class="source-line-no">774</span><span id="line-774">                results.put("RESULT", String.format(resultFormatTemplate, parts[0].trim(), encodedHmacComputed));</span>
<span class="source-line-no">775</span><span id="line-775">            }</span>
<span class="source-line-no">776</span><span id="line-776">            default -&gt; throw new IllegalArgumentException("Not supported processing mode!");</span>
<span class="source-line-no">777</span><span id="line-777">        }</span>
<span class="source-line-no">778</span><span id="line-778">        return results;</span>
<span class="source-line-no">779</span><span id="line-779">    }</span>
<span class="source-line-no">780</span><span id="line-780"></span>
<span class="source-line-no">781</span><span id="line-781">    /**</span>
<span class="source-line-no">782</span><span id="line-782">     * Apply a collection of validations on a JSON string provided:</span>
<span class="source-line-no">783</span><span id="line-783">     * &lt;ul&gt;</span>
<span class="source-line-no">784</span><span id="line-784">     * &lt;li&gt;Real JSON structure.&lt;/li&gt;</span>
<span class="source-line-no">785</span><span id="line-785">     * &lt;li&gt;Contain less than a specified number of deepness for nested objects or arrays.&lt;/li&gt;</span>
<span class="source-line-no">786</span><span id="line-786">     * &lt;li&gt;Contain less than a specified number of items in any arrays.&lt;/li&gt;</span>
<span class="source-line-no">787</span><span id="line-787">     * &lt;/ul&gt;</span>
<span class="source-line-no">788</span><span id="line-788">     * &lt;br&gt;</span>
<span class="source-line-no">789</span><span id="line-789">     * &lt;b&gt;Note:&lt;/b&gt; I decided to use a parsing approach using only string processing to prevent any StackOverFlow or OutOfMemory error that can be abused.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">790</span><span id="line-790">     * I used the following assumption:</span>
<span class="source-line-no">791</span><span id="line-791">     * &lt;ul&gt;</span>
<span class="source-line-no">792</span><span id="line-792">     *      &lt;li&gt;The character &lt;code&gt;{&lt;/code&gt; identify the beginning of an object.&lt;/li&gt;</span>
<span class="source-line-no">793</span><span id="line-793">     *      &lt;li&gt;The character &lt;code&gt;}&lt;/code&gt; identify the end of an object.&lt;/li&gt;</span>
<span class="source-line-no">794</span><span id="line-794">     *      &lt;li&gt;The character &lt;code&gt;[&lt;/code&gt; identify the beginning of an array.&lt;/li&gt;</span>
<span class="source-line-no">795</span><span id="line-795">     *      &lt;li&gt;The character &lt;code&gt;]&lt;/code&gt; identify the end of an array.&lt;/li&gt;</span>
<span class="source-line-no">796</span><span id="line-796">     *      &lt;li&gt;The character &lt;code&gt;"&lt;/code&gt; identify the delimiter of a string.&lt;/li&gt;</span>
<span class="source-line-no">797</span><span id="line-797">     *      &lt;li&gt;The character sequence &lt;code&gt;\"&lt;/code&gt; identify the escaping of an double quote.&lt;/li&gt;</span>
<span class="source-line-no">798</span><span id="line-798">     * &lt;/ul&gt;</span>
<span class="source-line-no">799</span><span id="line-799">     *</span>
<span class="source-line-no">800</span><span id="line-800">     * @param json                  String containing the JSON data to validate.</span>
<span class="source-line-no">801</span><span id="line-801">     * @param maxItemsByArraysCount Maximum number of items allowed in an array.</span>
<span class="source-line-no">802</span><span id="line-802">     * @param maxDeepnessAllowed    Maximum number nested objects or arrays allowed.</span>
<span class="source-line-no">803</span><span id="line-803">     * @return True only if the string pass all validations.</span>
<span class="source-line-no">804</span><span id="line-804">     * @see "https://javaee.github.io/jsonp/"</span>
<span class="source-line-no">805</span><span id="line-805">     * @see "https://community.f5.com/discussions/technicalforum/disable-buffer-overflow-in-json-parameters/124306"</span>
<span class="source-line-no">806</span><span id="line-806">     * @see "https://github.com/InductiveComputerScience/pbJson/issues/2"</span>
<span class="source-line-no">807</span><span id="line-807">     */</span>
<span class="source-line-no">808</span><span id="line-808">    public static boolean isJSONSafe(String json, int maxItemsByArraysCount, int maxDeepnessAllowed) {</span>
<span class="source-line-no">809</span><span id="line-809">        boolean isSafe = false;</span>
<span class="source-line-no">810</span><span id="line-810"></span>
<span class="source-line-no">811</span><span id="line-811">        try {</span>
<span class="source-line-no">812</span><span id="line-812">            //Step 1: Analyse the JSON string</span>
<span class="source-line-no">813</span><span id="line-813">            int currentDeepness = 0;</span>
<span class="source-line-no">814</span><span id="line-814">            int currentArrayItemsCount = 0;</span>
<span class="source-line-no">815</span><span id="line-815">            int maxDeepnessReached = 0;</span>
<span class="source-line-no">816</span><span id="line-816">            int maxArrayItemsCountReached = 0;</span>
<span class="source-line-no">817</span><span id="line-817">            boolean currentlyInArray = false;</span>
<span class="source-line-no">818</span><span id="line-818">            boolean currentlyInString = false;</span>
<span class="source-line-no">819</span><span id="line-819">            int currentNestedArrayLevel = 0;</span>
<span class="source-line-no">820</span><span id="line-820">            String jsonEscapedDoubleQuote = "\\\"";//Escaped double quote must not be considered as a string delimiter</span>
<span class="source-line-no">821</span><span id="line-821">            String work = json.replace(jsonEscapedDoubleQuote, "'");</span>
<span class="source-line-no">822</span><span id="line-822">            for (char c : work.toCharArray()) {</span>
<span class="source-line-no">823</span><span id="line-823">                switch (c) {</span>
<span class="source-line-no">824</span><span id="line-824">                    case '{': {</span>
<span class="source-line-no">825</span><span id="line-825">                        if (!currentlyInString) {</span>
<span class="source-line-no">826</span><span id="line-826">                            currentDeepness++;</span>
<span class="source-line-no">827</span><span id="line-827">                        }</span>
<span class="source-line-no">828</span><span id="line-828">                        break;</span>
<span class="source-line-no">829</span><span id="line-829">                    }</span>
<span class="source-line-no">830</span><span id="line-830">                    case '}': {</span>
<span class="source-line-no">831</span><span id="line-831">                        if (!currentlyInString) {</span>
<span class="source-line-no">832</span><span id="line-832">                            currentDeepness--;</span>
<span class="source-line-no">833</span><span id="line-833">                        }</span>
<span class="source-line-no">834</span><span id="line-834">                        break;</span>
<span class="source-line-no">835</span><span id="line-835">                    }</span>
<span class="source-line-no">836</span><span id="line-836">                    case '[': {</span>
<span class="source-line-no">837</span><span id="line-837">                        if (!currentlyInString) {</span>
<span class="source-line-no">838</span><span id="line-838">                            currentDeepness++;</span>
<span class="source-line-no">839</span><span id="line-839">                            if (currentlyInArray) {</span>
<span class="source-line-no">840</span><span id="line-840">                                currentNestedArrayLevel++;</span>
<span class="source-line-no">841</span><span id="line-841">                            }</span>
<span class="source-line-no">842</span><span id="line-842">                            currentlyInArray = true;</span>
<span class="source-line-no">843</span><span id="line-843">                        }</span>
<span class="source-line-no">844</span><span id="line-844">                        break;</span>
<span class="source-line-no">845</span><span id="line-845">                    }</span>
<span class="source-line-no">846</span><span id="line-846">                    case ']': {</span>
<span class="source-line-no">847</span><span id="line-847">                        if (!currentlyInString) {</span>
<span class="source-line-no">848</span><span id="line-848">                            currentDeepness--;</span>
<span class="source-line-no">849</span><span id="line-849">                            currentArrayItemsCount = 0;</span>
<span class="source-line-no">850</span><span id="line-850">                            if (currentNestedArrayLevel &gt; 0) {</span>
<span class="source-line-no">851</span><span id="line-851">                                currentNestedArrayLevel--;</span>
<span class="source-line-no">852</span><span id="line-852">                            }</span>
<span class="source-line-no">853</span><span id="line-853">                            if (currentNestedArrayLevel == 0) {</span>
<span class="source-line-no">854</span><span id="line-854">                                currentlyInArray = false;</span>
<span class="source-line-no">855</span><span id="line-855">                            }</span>
<span class="source-line-no">856</span><span id="line-856">                        }</span>
<span class="source-line-no">857</span><span id="line-857">                        break;</span>
<span class="source-line-no">858</span><span id="line-858">                    }</span>
<span class="source-line-no">859</span><span id="line-859">                    case '"': {</span>
<span class="source-line-no">860</span><span id="line-860">                        currentlyInString = !currentlyInString;</span>
<span class="source-line-no">861</span><span id="line-861">                        break;</span>
<span class="source-line-no">862</span><span id="line-862">                    }</span>
<span class="source-line-no">863</span><span id="line-863">                    case ',': {</span>
<span class="source-line-no">864</span><span id="line-864">                        if (!currentlyInString &amp;&amp; currentlyInArray) {</span>
<span class="source-line-no">865</span><span id="line-865">                            currentArrayItemsCount++;</span>
<span class="source-line-no">866</span><span id="line-866">                        }</span>
<span class="source-line-no">867</span><span id="line-867">                        break;</span>
<span class="source-line-no">868</span><span id="line-868">                    }</span>
<span class="source-line-no">869</span><span id="line-869">                }</span>
<span class="source-line-no">870</span><span id="line-870">                if (currentDeepness &gt; maxDeepnessReached) {</span>
<span class="source-line-no">871</span><span id="line-871">                    maxDeepnessReached = currentDeepness;</span>
<span class="source-line-no">872</span><span id="line-872">                }</span>
<span class="source-line-no">873</span><span id="line-873">                if (currentArrayItemsCount &gt; maxArrayItemsCountReached) {</span>
<span class="source-line-no">874</span><span id="line-874">                    maxArrayItemsCountReached = currentArrayItemsCount;</span>
<span class="source-line-no">875</span><span id="line-875">                }</span>
<span class="source-line-no">876</span><span id="line-876">            }</span>
<span class="source-line-no">877</span><span id="line-877">            //Step 2: Apply validation against the value specified as limits</span>
<span class="source-line-no">878</span><span id="line-878">            isSafe = ((maxItemsByArraysCount &gt; maxArrayItemsCountReached) &amp;&amp; (maxDeepnessAllowed &gt; maxDeepnessReached));</span>
<span class="source-line-no">879</span><span id="line-879"></span>
<span class="source-line-no">880</span><span id="line-880">            //Step 3: If the content is safe then ensure that it is valid JSON structure using the "Java API for JSON Processing" (JSR 374) parser reference implementation.</span>
<span class="source-line-no">881</span><span id="line-881">            if (isSafe) {</span>
<span class="source-line-no">882</span><span id="line-882">                JsonReader reader = Json.createReader(new StringReader(json));</span>
<span class="source-line-no">883</span><span id="line-883">                isSafe = (reader.read() != null);</span>
<span class="source-line-no">884</span><span id="line-884">            }</span>
<span class="source-line-no">885</span><span id="line-885"></span>
<span class="source-line-no">886</span><span id="line-886">        } catch (Exception e) {</span>
<span class="source-line-no">887</span><span id="line-887">            isSafe = false;</span>
<span class="source-line-no">888</span><span id="line-888">        }</span>
<span class="source-line-no">889</span><span id="line-889">        return isSafe;</span>
<span class="source-line-no">890</span><span id="line-890">    }</span>
<span class="source-line-no">891</span><span id="line-891"></span>
<span class="source-line-no">892</span><span id="line-892">    /**</span>
<span class="source-line-no">893</span><span id="line-893">     * Apply a collection of validations on a image file provided:</span>
<span class="source-line-no">894</span><span id="line-894">     * &lt;ul&gt;</span>
<span class="source-line-no">895</span><span id="line-895">     * &lt;li&gt;Real image file.&lt;/li&gt;</span>
<span class="source-line-no">896</span><span id="line-896">     * &lt;li&gt;Its mime type is into the list of allowed mime types.&lt;/li&gt;</span>
<span class="source-line-no">897</span><span id="line-897">     * &lt;li&gt;Its metadata fields do not contains any characters related to a malicious payloads.&lt;/li&gt;</span>
<span class="source-line-no">898</span><span id="line-898">     * &lt;/ul&gt;</span>
<span class="source-line-no">899</span><span id="line-899">     * &lt;br&gt;</span>
<span class="source-line-no">900</span><span id="line-900">     * &lt;b&gt;Important note:&lt;/b&gt; This implementation is prone to bypass using the "&lt;b&gt;raw insertion&lt;/b&gt;" method documented in the &lt;a href="https://www.synacktiv.com/en/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there"&gt;blog post&lt;/a&gt; from the Synacktiv team.</span>
<span class="source-line-no">901</span><span id="line-901">     * To handle such case, it is recommended to resize the image to remove any non image-related content, see &lt;a href="https://github.com/righettod/document-upload-protection/blob/master/src/main/java/eu/righettod/poc/sanitizer/ImageDocumentSanitizerImpl.java#L54"&gt;here&lt;/a&gt; for an example.&lt;br&gt;</span>
<span class="source-line-no">902</span><span id="line-902">     *</span>
<span class="source-line-no">903</span><span id="line-903">     * @param imageFilePath         Filename of the image file to check.</span>
<span class="source-line-no">904</span><span id="line-904">     * @param imageAllowedMimeTypes List of image mime types allowed.</span>
<span class="source-line-no">905</span><span id="line-905">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">906</span><span id="line-906">     * @see "https://commons.apache.org/proper/commons-imaging/"</span>
<span class="source-line-no">907</span><span id="line-907">     * @see "https://commons.apache.org/proper/commons-imaging/formatsupport.html"</span>
<span class="source-line-no">908</span><span id="line-908">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types"</span>
<span class="source-line-no">909</span><span id="line-909">     * @see "https://www.iana.org/assignments/media-types/media-types.xhtml#image"</span>
<span class="source-line-no">910</span><span id="line-910">     * @see "https://www.synacktiv.com/en/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there"</span>
<span class="source-line-no">911</span><span id="line-911">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html"</span>
<span class="source-line-no">912</span><span id="line-912">     * @see "https://github.com/righettod/document-upload-protection/blob/master/src/main/java/eu/righettod/poc/sanitizer/ImageDocumentSanitizerImpl.java"</span>
<span class="source-line-no">913</span><span id="line-913">     * @see "https://exiftool.org/examples.html"</span>
<span class="source-line-no">914</span><span id="line-914">     * @see "https://en.wikipedia.org/wiki/List_of_file_signatures"</span>
<span class="source-line-no">915</span><span id="line-915">     * @see "https://hexed.it/"</span>
<span class="source-line-no">916</span><span id="line-916">     * @see "https://github.com/sighook/pixload"</span>
<span class="source-line-no">917</span><span id="line-917">     */</span>
<span class="source-line-no">918</span><span id="line-918">    public static boolean isImageSafe(String imageFilePath, List&lt;String&gt; imageAllowedMimeTypes) {</span>
<span class="source-line-no">919</span><span id="line-919">        boolean isSafe = false;</span>
<span class="source-line-no">920</span><span id="line-920">        Pattern payloadDetectionRegex = Pattern.compile("[&lt;&gt;${}`]+", Pattern.CASE_INSENSITIVE);</span>
<span class="source-line-no">921</span><span id="line-921">        try {</span>
<span class="source-line-no">922</span><span id="line-922">            File imgFile = new File(imageFilePath);</span>
<span class="source-line-no">923</span><span id="line-923">            if (imgFile.exists() &amp;&amp; imgFile.canRead() &amp;&amp; imgFile.isFile() &amp;&amp; !imageAllowedMimeTypes.isEmpty()) {</span>
<span class="source-line-no">924</span><span id="line-924">                final byte[] imgBytes = Files.readAllBytes(imgFile.toPath());</span>
<span class="source-line-no">925</span><span id="line-925">                //Step 1: Check the mime type of the file against the allowed ones</span>
<span class="source-line-no">926</span><span id="line-926">                ImageInfo imgInfo = Imaging.getImageInfo(imgBytes);</span>
<span class="source-line-no">927</span><span id="line-927">                if (imageAllowedMimeTypes.contains(imgInfo.getMimeType())) {</span>
<span class="source-line-no">928</span><span id="line-928">                    //Step 2: Load the image into an object using the Image API</span>
<span class="source-line-no">929</span><span id="line-929">                    BufferedImage imgObject = Imaging.getBufferedImage(imgBytes);</span>
<span class="source-line-no">930</span><span id="line-930">                    if (imgObject != null &amp;&amp; imgObject.getWidth() &gt; 0 &amp;&amp; imgObject.getHeight() &gt; 0) {</span>
<span class="source-line-no">931</span><span id="line-931">                        //Step 3: Check the metadata if the image format support it - Highly experimental</span>
<span class="source-line-no">932</span><span id="line-932">                        List&lt;String&gt; metadataWithPayloads = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">933</span><span id="line-933">                        final ImageMetadata imgMetadata = Imaging.getMetadata(imgBytes);</span>
<span class="source-line-no">934</span><span id="line-934">                        if (imgMetadata != null) {</span>
<span class="source-line-no">935</span><span id="line-935">                            imgMetadata.getItems().forEach(item -&gt; {</span>
<span class="source-line-no">936</span><span id="line-936">                                String metadata = item.toString();</span>
<span class="source-line-no">937</span><span id="line-937">                                if (payloadDetectionRegex.matcher(metadata).find()) {</span>
<span class="source-line-no">938</span><span id="line-938">                                    metadataWithPayloads.add(metadata);</span>
<span class="source-line-no">939</span><span id="line-939">                                }</span>
<span class="source-line-no">940</span><span id="line-940">                            });</span>
<span class="source-line-no">941</span><span id="line-941">                        }</span>
<span class="source-line-no">942</span><span id="line-942">                        isSafe = metadataWithPayloads.isEmpty();</span>
<span class="source-line-no">943</span><span id="line-943">                    }</span>
<span class="source-line-no">944</span><span id="line-944">                }</span>
<span class="source-line-no">945</span><span id="line-945">            }</span>
<span class="source-line-no">946</span><span id="line-946">        } catch (Exception e) {</span>
<span class="source-line-no">947</span><span id="line-947">            isSafe = false;</span>
<span class="source-line-no">948</span><span id="line-948">        }</span>
<span class="source-line-no">949</span><span id="line-949">        return isSafe;</span>
<span class="source-line-no">950</span><span id="line-950">    }</span>
<span class="source-line-no">951</span><span id="line-951"></span>
<span class="source-line-no">952</span><span id="line-952">    /**</span>
<span class="source-line-no">953</span><span id="line-953">     * Rewrite the input file to remove any embedded files that is not embedded using a methods supported by the official format of the file.&lt;br&gt;</span>
<span class="source-line-no">954</span><span id="line-954">     * Example: a file can be embedded by adding it to the end of the source file, see the reference provided for details.</span>
<span class="source-line-no">955</span><span id="line-955">     *</span>
<span class="source-line-no">956</span><span id="line-956">     * @param inputFilePath Filename of the file to clean up.</span>
<span class="source-line-no">957</span><span id="line-957">     * @param inputFileType Type of the file provided.</span>
<span class="source-line-no">958</span><span id="line-958">     * @return A array of bytes with the cleaned file.</span>
<span class="source-line-no">959</span><span id="line-959">     * @throws IllegalArgumentException If an invalid parameter is passed</span>
<span class="source-line-no">960</span><span id="line-960">     * @throws Exception                If any technical error during the cleaning processing</span>
<span class="source-line-no">961</span><span id="line-961">     * @see "https://www.synacktiv.com/en/publications/persistent-php-payloads-in-pngs-how-to-inject-php-code-in-an-image-and-keep-it-there"</span>
<span class="source-line-no">962</span><span id="line-962">     * @see "https://github.com/righettod/toolbox-pentest-web/tree/master/misc"</span>
<span class="source-line-no">963</span><span id="line-963">     * @see "https://github.com/righettod/toolbox-pentest-web?tab=readme-ov-file#misc"</span>
<span class="source-line-no">964</span><span id="line-964">     * @see "https://stackoverflow.com/a/13605411"</span>
<span class="source-line-no">965</span><span id="line-965">     */</span>
<span class="source-line-no">966</span><span id="line-966">    public static byte[] sanitizeFile(String inputFilePath, InputFileType inputFileType) throws Exception {</span>
<span class="source-line-no">967</span><span id="line-967">        ByteArrayOutputStream sanitizedContent = new ByteArrayOutputStream();</span>
<span class="source-line-no">968</span><span id="line-968">        File inputFile = new File(inputFilePath);</span>
<span class="source-line-no">969</span><span id="line-969">        if (!inputFile.exists() || !inputFile.canRead() || !inputFile.isFile()) {</span>
<span class="source-line-no">970</span><span id="line-970">            throw new IllegalArgumentException("Cannot read the content of the input file!");</span>
<span class="source-line-no">971</span><span id="line-971">        }</span>
<span class="source-line-no">972</span><span id="line-972">        switch (inputFileType) {</span>
<span class="source-line-no">973</span><span id="line-973">            case PDF -&gt; {</span>
<span class="source-line-no">974</span><span id="line-974">                try (PDDocument document = Loader.loadPDF(inputFile)) {</span>
<span class="source-line-no">975</span><span id="line-975">                    document.save(sanitizedContent);</span>
<span class="source-line-no">976</span><span id="line-976">                }</span>
<span class="source-line-no">977</span><span id="line-977">            }</span>
<span class="source-line-no">978</span><span id="line-978">            case IMAGE -&gt; {</span>
<span class="source-line-no">979</span><span id="line-979">                // Load the original image</span>
<span class="source-line-no">980</span><span id="line-980">                BufferedImage originalImage = ImageIO.read(inputFile);</span>
<span class="source-line-no">981</span><span id="line-981">                String originalFormat = identifyMimeType(Files.readAllBytes(inputFile.toPath())).split("/")[1].trim();</span>
<span class="source-line-no">982</span><span id="line-982">                // Check that image has been successfully loaded</span>
<span class="source-line-no">983</span><span id="line-983">                if (originalImage == null) {</span>
<span class="source-line-no">984</span><span id="line-984">                    throw new IOException("Cannot load the original image !");</span>
<span class="source-line-no">985</span><span id="line-985">                }</span>
<span class="source-line-no">986</span><span id="line-986">                // Get current Width and Height of the image</span>
<span class="source-line-no">987</span><span id="line-987">                int originalWidth = originalImage.getWidth(null);</span>
<span class="source-line-no">988</span><span id="line-988">                int originalHeight = originalImage.getHeight(null);</span>
<span class="source-line-no">989</span><span id="line-989">                // Resize the image by removing 1px on Width and Height</span>
<span class="source-line-no">990</span><span id="line-990">                Image resizedImage = originalImage.getScaledInstance(originalWidth - 1, originalHeight - 1, Image.SCALE_SMOOTH);</span>
<span class="source-line-no">991</span><span id="line-991">                // Resize the resized image by adding 1px on Width and Height - In fact set image to is initial size</span>
<span class="source-line-no">992</span><span id="line-992">                Image initialSizedImage = resizedImage.getScaledInstance(originalWidth, originalHeight, Image.SCALE_SMOOTH);</span>
<span class="source-line-no">993</span><span id="line-993">                // Save image to a bytes buffer</span>
<span class="source-line-no">994</span><span id="line-994">                int bufferedImageType = BufferedImage.TYPE_INT_ARGB;//By default use a format supporting transparency</span>
<span class="source-line-no">995</span><span id="line-995">                if ("jpeg".equalsIgnoreCase(originalFormat) || "bmp".equalsIgnoreCase(originalFormat)) {</span>
<span class="source-line-no">996</span><span id="line-996">                    bufferedImageType = BufferedImage.TYPE_INT_RGB;</span>
<span class="source-line-no">997</span><span id="line-997">                }</span>
<span class="source-line-no">998</span><span id="line-998">                BufferedImage sanitizedImage = new BufferedImage(initialSizedImage.getWidth(null), initialSizedImage.getHeight(null), bufferedImageType);</span>
<span class="source-line-no">999</span><span id="line-999">                Graphics2D drawer = sanitizedImage.createGraphics();</span>
<span class="source-line-no">1000</span><span id="line-1000">                drawer.drawImage(initialSizedImage, 0, 0, null);</span>
<span class="source-line-no">1001</span><span id="line-1001">                drawer.dispose();</span>
<span class="source-line-no">1002</span><span id="line-1002">                ImageIO.write(sanitizedImage, originalFormat, sanitizedContent);</span>
<span class="source-line-no">1003</span><span id="line-1003">            }</span>
<span class="source-line-no">1004</span><span id="line-1004">            default -&gt; throw new IllegalArgumentException("Type of file not supported !");</span>
<span class="source-line-no">1005</span><span id="line-1005">        }</span>
<span class="source-line-no">1006</span><span id="line-1006">        if (sanitizedContent.size() == 0) {</span>
<span class="source-line-no">1007</span><span id="line-1007">            throw new IOException("An error occur during the rewrite operation!");</span>
<span class="source-line-no">1008</span><span id="line-1008">        }</span>
<span class="source-line-no">1009</span><span id="line-1009">        return sanitizedContent.toByteArray();</span>
<span class="source-line-no">1010</span><span id="line-1010">    }</span>
<span class="source-line-no">1011</span><span id="line-1011"></span>
<span class="source-line-no">1012</span><span id="line-1012">    /**</span>
<span class="source-line-no">1013</span><span id="line-1013">     * Apply a collection of validations on a string expected to be an email address:</span>
<span class="source-line-no">1014</span><span id="line-1014">     * &lt;ul&gt;</span>
<span class="source-line-no">1015</span><span id="line-1015">     * &lt;li&gt;Is a valid email address, from a parser perspective, following RFCs on email addresses.&lt;/li&gt;</span>
<span class="source-line-no">1016</span><span id="line-1016">     * &lt;li&gt;Is not using "Encoded-word" format.&lt;/li&gt;</span>
<span class="source-line-no">1017</span><span id="line-1017">     * &lt;li&gt;Is not using comment format.&lt;/li&gt;</span>
<span class="source-line-no">1018</span><span id="line-1018">     * &lt;li&gt;Is not using "Punycode" format.&lt;/li&gt;</span>
<span class="source-line-no">1019</span><span id="line-1019">     * &lt;li&gt;Is not using UUCP style addresses.&lt;/li&gt;</span>
<span class="source-line-no">1020</span><span id="line-1020">     * &lt;li&gt;Is not using address literals.&lt;/li&gt;</span>
<span class="source-line-no">1021</span><span id="line-1021">     * &lt;li&gt;Is not using source routes.&lt;/li&gt;</span>
<span class="source-line-no">1022</span><span id="line-1022">     * &lt;li&gt;Is not using the "percent hack".&lt;/li&gt;</span>
<span class="source-line-no">1023</span><span id="line-1023">     * &lt;/ul&gt;&lt;br&gt;</span>
<span class="source-line-no">1024</span><span id="line-1024">     * This is based on the research work from &lt;a href="https://portswigger.net/research/gareth-heyes"&gt;Gareth Heyes&lt;/a&gt; added in references (Portswigger).&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">1025</span><span id="line-1025">     *</span>
<span class="source-line-no">1026</span><span id="line-1026">     * &lt;b&gt;Note:&lt;/b&gt; The notion of valid, here, is to take from a secure usage of the data perspective.</span>
<span class="source-line-no">1027</span><span id="line-1027">     *</span>
<span class="source-line-no">1028</span><span id="line-1028">     * @param addr String expected to be a valid email address.</span>
<span class="source-line-no">1029</span><span id="line-1029">     * @return True only if the string pass all validations.</span>
<span class="source-line-no">1030</span><span id="line-1030">     * @see "https://commons.apache.org/proper/commons-validator/"</span>
<span class="source-line-no">1031</span><span id="line-1031">     * @see "https://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/routines/EmailValidator.html"</span>
<span class="source-line-no">1032</span><span id="line-1032">     * @see "https://datatracker.ietf.org/doc/html/rfc2047#section-2"</span>
<span class="source-line-no">1033</span><span id="line-1033">     * @see "https://portswigger.net/research/splitting-the-email-atom"</span>
<span class="source-line-no">1034</span><span id="line-1034">     * @see "https://www.jochentopf.com/email/address.html"</span>
<span class="source-line-no">1035</span><span id="line-1035">     * @see "https://en.wikipedia.org/wiki/Email_address"</span>
<span class="source-line-no">1036</span><span id="line-1036">     */</span>
<span class="source-line-no">1037</span><span id="line-1037">    public static boolean isEmailAddress(String addr) {</span>
<span class="source-line-no">1038</span><span id="line-1038">        boolean isValid = false;</span>
<span class="source-line-no">1039</span><span id="line-1039">        String work = addr.toLowerCase(Locale.ROOT);</span>
<span class="source-line-no">1040</span><span id="line-1040">        Pattern encodedWordRegex = Pattern.compile("[=?]+", Pattern.CASE_INSENSITIVE);</span>
<span class="source-line-no">1041</span><span id="line-1041">        Pattern forbiddenCharacterRegex = Pattern.compile("[():!%\\[\\],;]+", Pattern.CASE_INSENSITIVE);</span>
<span class="source-line-no">1042</span><span id="line-1042">        try {</span>
<span class="source-line-no">1043</span><span id="line-1043">            //Start with the use of the dedicated EmailValidator from Apache Commons Validator</span>
<span class="source-line-no">1044</span><span id="line-1044">            if (EmailValidator.getInstance(true, true).isValid(work)) {</span>
<span class="source-line-no">1045</span><span id="line-1045">                //If OK then validate it does not contains "Encoded-word" patterns using an aggressive approach</span>
<span class="source-line-no">1046</span><span id="line-1046">                if (!encodedWordRegex.matcher(work).find()) {</span>
<span class="source-line-no">1047</span><span id="line-1047">                    //If OK then validate it does not contains punycode</span>
<span class="source-line-no">1048</span><span id="line-1048">                    if (!work.contains("xn--")) {</span>
<span class="source-line-no">1049</span><span id="line-1049">                        //If OK then validate it does not use:</span>
<span class="source-line-no">1050</span><span id="line-1050">                        // UUCP style addresses,</span>
<span class="source-line-no">1051</span><span id="line-1051">                        // Comment format,</span>
<span class="source-line-no">1052</span><span id="line-1052">                        // Address literals,</span>
<span class="source-line-no">1053</span><span id="line-1053">                        // Source routes,</span>
<span class="source-line-no">1054</span><span id="line-1054">                        // The percent hack.</span>
<span class="source-line-no">1055</span><span id="line-1055">                        if (!forbiddenCharacterRegex.matcher(work).find()) {</span>
<span class="source-line-no">1056</span><span id="line-1056">                            isValid = true;</span>
<span class="source-line-no">1057</span><span id="line-1057">                        }</span>
<span class="source-line-no">1058</span><span id="line-1058">                    }</span>
<span class="source-line-no">1059</span><span id="line-1059">                }</span>
<span class="source-line-no">1060</span><span id="line-1060">            }</span>
<span class="source-line-no">1061</span><span id="line-1061">        } catch (Exception e) {</span>
<span class="source-line-no">1062</span><span id="line-1062">            isValid = false;</span>
<span class="source-line-no">1063</span><span id="line-1063">        }</span>
<span class="source-line-no">1064</span><span id="line-1064">        return isValid;</span>
<span class="source-line-no">1065</span><span id="line-1065">    }</span>
<span class="source-line-no">1066</span><span id="line-1066"></span>
<span class="source-line-no">1067</span><span id="line-1067">    /**</span>
<span class="source-line-no">1068</span><span id="line-1068">     * The &lt;a href="https://www.stet.eu/en/psd2/"&gt;PSD2 STET&lt;/a&gt; specification require to use &lt;a href="https://datatracker.ietf.org/doc/draft-cavage-http-signatures/"&gt;HTTP Signature&lt;/a&gt;.</span>
<span class="source-line-no">1069</span><span id="line-1069">     * &lt;br&gt;</span>
<span class="source-line-no">1070</span><span id="line-1070">     * Section &lt;b&gt;3.5.1.2&lt;/b&gt; of the document &lt;a href="https://www.stet.eu/assets/files/PSD2/1-6-3/api-dsp2-stet-v1.6.3.1-part-1-framework.pdf"&gt;Documentation Framework&lt;/a&gt; version &lt;b&gt;1.6.3&lt;/b&gt;.</span>
<span class="source-line-no">1071</span><span id="line-1071">     * &lt;br&gt;</span>
<span class="source-line-no">1072</span><span id="line-1072">     * The problem is that, by design, the HTTP Signature specification is prone to blind SSRF.</span>
<span class="source-line-no">1073</span><span id="line-1073">     * &lt;br&gt;</span>
<span class="source-line-no">1074</span><span id="line-1074">     * URL example taken from the STET specification: &lt;code&gt;https://path.to/myQsealCertificate_714f8154ec259ac40b8a9786c9908488b2582b68b17e865fede4636d726b709f&lt;/code&gt;.</span>
<span class="source-line-no">1075</span><span id="line-1075">     * &lt;br&gt;</span>
<span class="source-line-no">1076</span><span id="line-1076">     * The objective of this code is to try to decrease the "exploitability/interest" of this SSRF for an attacker.</span>
<span class="source-line-no">1077</span><span id="line-1077">     *</span>
<span class="source-line-no">1078</span><span id="line-1078">     * @param certificateUrl Url pointing to a Qualified Certificate (QSealC) encoded in PEM format and respecting the ETSI/TS119495 technical Specification .</span>
<span class="source-line-no">1079</span><span id="line-1079">     * @return TRUE only if the url point to a Qualified Certificate in PEM format.</span>
<span class="source-line-no">1080</span><span id="line-1080">     * @see "https://www.stet.eu/en/psd2/"</span>
<span class="source-line-no">1081</span><span id="line-1081">     * @see "https://www.stet.eu/assets/files/PSD2/1-6-3/api-dsp2-stet-v1.6.3.1-part-1-framework.pdf"</span>
<span class="source-line-no">1082</span><span id="line-1082">     * @see "https://datatracker.ietf.org/doc/draft-cavage-http-signatures/"</span>
<span class="source-line-no">1083</span><span id="line-1083">     * @see "https://datatracker.ietf.org/doc/rfc9421/"</span>
<span class="source-line-no">1084</span><span id="line-1084">     * @see "https://openjdk.org/groups/net/httpclient/intro.html"</span>
<span class="source-line-no">1085</span><span id="line-1085">     * @see "https://docs.oracle.com/en/java/javase/21/docs/api/java.net.http/java/net/http/package-summary.html"</span>
<span class="source-line-no">1086</span><span id="line-1086">     * @see "https://portswigger.net/web-security/ssrf"</span>
<span class="source-line-no">1087</span><span id="line-1087">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control"</span>
<span class="source-line-no">1088</span><span id="line-1088">     */</span>
<span class="source-line-no">1089</span><span id="line-1089">    public static boolean isPSD2StetSafeCertificateURL(String certificateUrl) {</span>
<span class="source-line-no">1090</span><span id="line-1090">        boolean isValid = false;</span>
<span class="source-line-no">1091</span><span id="line-1091">        long connectionTimeoutInSeconds = 10;</span>
<span class="source-line-no">1092</span><span id="line-1092">        String userAgent = "PSD2-STET-HTTPSignature-CertificateRequest";</span>
<span class="source-line-no">1093</span><span id="line-1093">        try {</span>
<span class="source-line-no">1094</span><span id="line-1094">            //1. Ensure that the URL end with the SHA-256 fingerprint encoded in HEX of the certificate like requested by STET</span>
<span class="source-line-no">1095</span><span id="line-1095">            if (certificateUrl != null &amp;&amp; certificateUrl.lastIndexOf("_") != -1) {</span>
<span class="source-line-no">1096</span><span id="line-1096">                String digestPart = certificateUrl.substring(certificateUrl.lastIndexOf("_") + 1);</span>
<span class="source-line-no">1097</span><span id="line-1097">                if (Pattern.matches("^[0-9a-f]{64}$", digestPart)) {</span>
<span class="source-line-no">1098</span><span id="line-1098">                    //2. Ensure that the URL is a valid url by creating a instance of the class URI</span>
<span class="source-line-no">1099</span><span id="line-1099">                    URI uri = URI.create(certificateUrl);</span>
<span class="source-line-no">1100</span><span id="line-1100">                    //3. Require usage of HTTPS and reject any url containing query parameters</span>
<span class="source-line-no">1101</span><span id="line-1101">                    if ("https".equalsIgnoreCase(uri.getScheme()) &amp;&amp; uri.getQuery() == null) {</span>
<span class="source-line-no">1102</span><span id="line-1102">                        //4. Perform a HTTP HEAD request in order to get the content type of the remote resource</span>
<span class="source-line-no">1103</span><span id="line-1103">                        //and limit the interest to use the SSRF because to pass the check the url need to:</span>
<span class="source-line-no">1104</span><span id="line-1104">                        //- Do not having any query parameters.</span>
<span class="source-line-no">1105</span><span id="line-1105">                        //- Use HTTPS protocol.</span>
<span class="source-line-no">1106</span><span id="line-1106">                        //- End with a string having the format "_[0-9a-f]{64}".</span>
<span class="source-line-no">1107</span><span id="line-1107">                        //- Trigger the malicious action that the attacker want but with a HTTP HEAD without any redirect and parameters.</span>
<span class="source-line-no">1108</span><span id="line-1108">                        HttpResponse&lt;String&gt; response;</span>
<span class="source-line-no">1109</span><span id="line-1109">                        try (HttpClient client = HttpClient.newBuilder().followRedirects(HttpClient.Redirect.NEVER).build()) {</span>
<span class="source-line-no">1110</span><span id="line-1110">                            HttpRequest request = HttpRequest.newBuilder().uri(uri).timeout(Duration.ofSeconds(connectionTimeoutInSeconds)).method("HEAD", HttpRequest.BodyPublishers.noBody()).header("User-Agent", userAgent)//To provide an hint to the target about the initiator of the request</span>
<span class="source-line-no">1111</span><span id="line-1111">                                    .header("Cache-Control", "no-store, max-age=0")//To prevent caching issues or abuses</span>
<span class="source-line-no">1112</span><span id="line-1112">                                    .build();</span>
<span class="source-line-no">1113</span><span id="line-1113">                            response = client.send(request, HttpResponse.BodyHandlers.ofString());</span>
<span class="source-line-no">1114</span><span id="line-1114">                            if (response.statusCode() == 200) {</span>
<span class="source-line-no">1115</span><span id="line-1115">                                //5. Ensure that the response content type is "text/plain"</span>
<span class="source-line-no">1116</span><span id="line-1116">                                Optional&lt;String&gt; contentType = response.headers().firstValue("Content-Type");</span>
<span class="source-line-no">1117</span><span id="line-1117">                                isValid = (contentType.isPresent() &amp;&amp; contentType.get().trim().toLowerCase(Locale.ENGLISH).startsWith("text/plain"));</span>
<span class="source-line-no">1118</span><span id="line-1118">                            }</span>
<span class="source-line-no">1119</span><span id="line-1119">                        }</span>
<span class="source-line-no">1120</span><span id="line-1120">                    }</span>
<span class="source-line-no">1121</span><span id="line-1121">                }</span>
<span class="source-line-no">1122</span><span id="line-1122">            }</span>
<span class="source-line-no">1123</span><span id="line-1123">        } catch (Exception e) {</span>
<span class="source-line-no">1124</span><span id="line-1124">            isValid = false;</span>
<span class="source-line-no">1125</span><span id="line-1125">        }</span>
<span class="source-line-no">1126</span><span id="line-1126">        return isValid;</span>
<span class="source-line-no">1127</span><span id="line-1127">    }</span>
<span class="source-line-no">1128</span><span id="line-1128"></span>
<span class="source-line-no">1129</span><span id="line-1129">    /**</span>
<span class="source-line-no">1130</span><span id="line-1130">     * Perform sequential URL decoding operations against a URL encoded data until the data is not URL encoded anymore or if the specified threshold is reached.</span>
<span class="source-line-no">1131</span><span id="line-1131">     *</span>
<span class="source-line-no">1132</span><span id="line-1132">     * @param encodedData            URL encoded data.</span>
<span class="source-line-no">1133</span><span id="line-1133">     * @param decodingRoundThreshold Threshold above which decoding will fail.</span>
<span class="source-line-no">1134</span><span id="line-1134">     * @return The decoded data.</span>
<span class="source-line-no">1135</span><span id="line-1135">     * @throws SecurityException If the threshold is reached.</span>
<span class="source-line-no">1136</span><span id="line-1136">     * @see "https://en.wikipedia.org/wiki/Percent-encoding"</span>
<span class="source-line-no">1137</span><span id="line-1137">     * @see "https://owasp.org/www-community/Double_Encoding"</span>
<span class="source-line-no">1138</span><span id="line-1138">     * @see "https://portswigger.net/web-security/essential-skills/obfuscating-attacks-using-encodings"</span>
<span class="source-line-no">1139</span><span id="line-1139">     * @see "https://capec.mitre.org/data/definitions/120.html"</span>
<span class="source-line-no">1140</span><span id="line-1140">     */</span>
<span class="source-line-no">1141</span><span id="line-1141">    public static String applyURLDecoding(String encodedData, int decodingRoundThreshold) throws SecurityException {</span>
<span class="source-line-no">1142</span><span id="line-1142">        if (decodingRoundThreshold &lt; 1) {</span>
<span class="source-line-no">1143</span><span id="line-1143">            throw new IllegalArgumentException("Threshold must be a positive number !");</span>
<span class="source-line-no">1144</span><span id="line-1144">        }</span>
<span class="source-line-no">1145</span><span id="line-1145">        if (encodedData == null) {</span>
<span class="source-line-no">1146</span><span id="line-1146">            throw new IllegalArgumentException("Data provided must not be null !");</span>
<span class="source-line-no">1147</span><span id="line-1147">        }</span>
<span class="source-line-no">1148</span><span id="line-1148">        Charset charset = StandardCharsets.UTF_8;</span>
<span class="source-line-no">1149</span><span id="line-1149">        int currentDecodingRound = 0;</span>
<span class="source-line-no">1150</span><span id="line-1150">        boolean isFinished = false;</span>
<span class="source-line-no">1151</span><span id="line-1151">        String currentRoundData = encodedData;</span>
<span class="source-line-no">1152</span><span id="line-1152">        String previousRoundData = encodedData;</span>
<span class="source-line-no">1153</span><span id="line-1153">        while (!isFinished) {</span>
<span class="source-line-no">1154</span><span id="line-1154">            if (currentDecodingRound &gt; decodingRoundThreshold) {</span>
<span class="source-line-no">1155</span><span id="line-1155">                throw new SecurityException(String.format("Decoding round threshold of %s reached!", decodingRoundThreshold));</span>
<span class="source-line-no">1156</span><span id="line-1156">            }</span>
<span class="source-line-no">1157</span><span id="line-1157">            currentRoundData = URLDecoder.decode(currentRoundData, charset);</span>
<span class="source-line-no">1158</span><span id="line-1158">            isFinished = currentRoundData.equals(previousRoundData);</span>
<span class="source-line-no">1159</span><span id="line-1159">            previousRoundData = currentRoundData;</span>
<span class="source-line-no">1160</span><span id="line-1160">            currentDecodingRound++;</span>
<span class="source-line-no">1161</span><span id="line-1161">        }</span>
<span class="source-line-no">1162</span><span id="line-1162">        return currentRoundData;</span>
<span class="source-line-no">1163</span><span id="line-1163">    }</span>
<span class="source-line-no">1164</span><span id="line-1164"></span>
<span class="source-line-no">1165</span><span id="line-1165">    /**</span>
<span class="source-line-no">1166</span><span id="line-1166">     * Apply a collection of validations on a string expected to be an system file/folder path:</span>
<span class="source-line-no">1167</span><span id="line-1167">     * &lt;ul&gt;</span>
<span class="source-line-no">1168</span><span id="line-1168">     * &lt;li&gt;Does not contains path traversal payload.&lt;/li&gt;</span>
<span class="source-line-no">1169</span><span id="line-1169">     * &lt;li&gt;The canonical path is equals to the absolute path.&lt;/li&gt;</span>
<span class="source-line-no">1170</span><span id="line-1170">     * &lt;/ul&gt;&lt;br&gt;</span>
<span class="source-line-no">1171</span><span id="line-1171">     *</span>
<span class="source-line-no">1172</span><span id="line-1172">     * @param path String expected to be a valid system file/folder path.</span>
<span class="source-line-no">1173</span><span id="line-1173">     * @return True only if the string pass all validations.</span>
<span class="source-line-no">1174</span><span id="line-1174">     * @see "https://portswigger.net/web-security/file-path-traversal"</span>
<span class="source-line-no">1175</span><span id="line-1175">     * @see "https://learn.snyk.io/lesson/directory-traversal/"</span>
<span class="source-line-no">1176</span><span id="line-1176">     * @see "https://capec.mitre.org/data/definitions/126.html"</span>
<span class="source-line-no">1177</span><span id="line-1177">     * @see "https://owasp.org/www-community/attacks/Path_Traversal"</span>
<span class="source-line-no">1178</span><span id="line-1178">     */</span>
<span class="source-line-no">1179</span><span id="line-1179">    public static boolean isPathSafe(String path) {</span>
<span class="source-line-no">1180</span><span id="line-1180">        boolean isSafe = false;</span>
<span class="source-line-no">1181</span><span id="line-1181">        int decodingRoundThreshold = 3;</span>
<span class="source-line-no">1182</span><span id="line-1182">        try {</span>
<span class="source-line-no">1183</span><span id="line-1183">            if (path != null &amp;&amp; !path.isEmpty()) {</span>
<span class="source-line-no">1184</span><span id="line-1184">                //URL decode the path if case of data coming from a web context</span>
<span class="source-line-no">1185</span><span id="line-1185">                String decodedPath = applyURLDecoding(path, decodingRoundThreshold);</span>
<span class="source-line-no">1186</span><span id="line-1186">                //Ensure that no path traversal expression is present</span>
<span class="source-line-no">1187</span><span id="line-1187">                if (!decodedPath.contains("..")) {</span>
<span class="source-line-no">1188</span><span id="line-1188">                    File f = new File(decodedPath);</span>
<span class="source-line-no">1189</span><span id="line-1189">                    String canonicalPath = f.getCanonicalPath();</span>
<span class="source-line-no">1190</span><span id="line-1190">                    String absolutePath = f.getAbsolutePath();</span>
<span class="source-line-no">1191</span><span id="line-1191">                    isSafe = canonicalPath.equals(absolutePath);</span>
<span class="source-line-no">1192</span><span id="line-1192">                }</span>
<span class="source-line-no">1193</span><span id="line-1193">            }</span>
<span class="source-line-no">1194</span><span id="line-1194">        } catch (Exception e) {</span>
<span class="source-line-no">1195</span><span id="line-1195">            isSafe = false;</span>
<span class="source-line-no">1196</span><span id="line-1196">        }</span>
<span class="source-line-no">1197</span><span id="line-1197">        return isSafe;</span>
<span class="source-line-no">1198</span><span id="line-1198">    }</span>
<span class="source-line-no">1199</span><span id="line-1199"></span>
<span class="source-line-no">1200</span><span id="line-1200">    /**</span>
<span class="source-line-no">1201</span><span id="line-1201">     * Identify if an XML contains any XML comments or have any XSL processing instructions.&lt;br&gt;</span>
<span class="source-line-no">1202</span><span id="line-1202">     * Stream reader based parsing is used to support large XML tree.</span>
<span class="source-line-no">1203</span><span id="line-1203">     *</span>
<span class="source-line-no">1204</span><span id="line-1204">     * @param xmlFilePath Filename of the XML file to check.</span>
<span class="source-line-no">1205</span><span id="line-1205">     * @return True only if XML comments or XSL processing instructions are identified.</span>
<span class="source-line-no">1206</span><span id="line-1206">     * @see "https://www.tutorialspoint.com/xml/xml_processing.htm"</span>
<span class="source-line-no">1207</span><span id="line-1207">     * @see "https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/stream/XMLInputFactory.html"</span>
<span class="source-line-no">1208</span><span id="line-1208">     * @see "https://portswigger.net/kb/issues/00400700_xml-entity-expansion"</span>
<span class="source-line-no">1209</span><span id="line-1209">     * @see "https://www.w3.org/Style/styling-XML.en.html"</span>
<span class="source-line-no">1210</span><span id="line-1210">     */</span>
<span class="source-line-no">1211</span><span id="line-1211">    public static boolean isXMLHaveCommentsOrXSLProcessingInstructions(String xmlFilePath) {</span>
<span class="source-line-no">1212</span><span id="line-1212">        boolean itemsDetected = false;</span>
<span class="source-line-no">1213</span><span id="line-1213">        try {</span>
<span class="source-line-no">1214</span><span id="line-1214">            //Ensure that the parser will not be prone XML external entity (XXE) injection or XML entity expansion (XEE) attacks</span>
<span class="source-line-no">1215</span><span id="line-1215">            XMLInputFactory xmlInputFactory = XMLInputFactory.newFactory();</span>
<span class="source-line-no">1216</span><span id="line-1216">            xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);</span>
<span class="source-line-no">1217</span><span id="line-1217">            xmlInputFactory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");</span>
<span class="source-line-no">1218</span><span id="line-1218">            xmlInputFactory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, false);</span>
<span class="source-line-no">1219</span><span id="line-1219">            xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);</span>
<span class="source-line-no">1220</span><span id="line-1220"></span>
<span class="source-line-no">1221</span><span id="line-1221">            //Parse file</span>
<span class="source-line-no">1222</span><span id="line-1222">            try (FileInputStream fis = new FileInputStream(xmlFilePath)) {</span>
<span class="source-line-no">1223</span><span id="line-1223">                XMLStreamReader reader = xmlInputFactory.createXMLStreamReader(fis);</span>
<span class="source-line-no">1224</span><span id="line-1224">                int eventType;</span>
<span class="source-line-no">1225</span><span id="line-1225">                while (reader.hasNext() &amp;&amp; !itemsDetected) {</span>
<span class="source-line-no">1226</span><span id="line-1226">                    eventType = reader.next();</span>
<span class="source-line-no">1227</span><span id="line-1227">                    if (eventType == XMLEvent.COMMENT) {</span>
<span class="source-line-no">1228</span><span id="line-1228">                        itemsDetected = true;</span>
<span class="source-line-no">1229</span><span id="line-1229">                    } else if (eventType == XMLEvent.PROCESSING_INSTRUCTION &amp;&amp; "xml-stylesheet".equalsIgnoreCase(reader.getPITarget())) {</span>
<span class="source-line-no">1230</span><span id="line-1230">                        itemsDetected = true;</span>
<span class="source-line-no">1231</span><span id="line-1231">                    }</span>
<span class="source-line-no">1232</span><span id="line-1232">                }</span>
<span class="source-line-no">1233</span><span id="line-1233">            }</span>
<span class="source-line-no">1234</span><span id="line-1234">        } catch (Exception e) {</span>
<span class="source-line-no">1235</span><span id="line-1235">            //In case of error then assume that the check failed</span>
<span class="source-line-no">1236</span><span id="line-1236">            itemsDetected = true;</span>
<span class="source-line-no">1237</span><span id="line-1237">        }</span>
<span class="source-line-no">1238</span><span id="line-1238">        return itemsDetected;</span>
<span class="source-line-no">1239</span><span id="line-1239">    }</span>
<span class="source-line-no">1240</span><span id="line-1240"></span>
<span class="source-line-no">1241</span><span id="line-1241"></span>
<span class="source-line-no">1242</span><span id="line-1242">    /**</span>
<span class="source-line-no">1243</span><span id="line-1243">     * Perform a set of additional validations against a JWT token:</span>
<span class="source-line-no">1244</span><span id="line-1244">     * &lt;ul&gt;</span>
<span class="source-line-no">1245</span><span id="line-1245">     *     &lt;li&gt;Do not use the &lt;b&gt;NONE&lt;/b&gt; signature algorithm.&lt;/li&gt;</span>
<span class="source-line-no">1246</span><span id="line-1246">     *     &lt;li&gt;Have a &lt;a href="https://www.iana.org/assignments/jwt/jwt.xhtml"&gt;EXP claim&lt;/a&gt; defined.&lt;/li&gt;</span>
<span class="source-line-no">1247</span><span id="line-1247">     *     &lt;li&gt;The token identifier (&lt;a href="https://www.iana.org/assignments/jwt/jwt.xhtml"&gt;JTI claim&lt;/a&gt;) is NOT part of the list of revoked token.&lt;/li&gt;</span>
<span class="source-line-no">1248</span><span id="line-1248">     *     &lt;li&gt;Match the expected type of token: ACCESS or ID or REFRESH.&lt;/li&gt;</span>
<span class="source-line-no">1249</span><span id="line-1249">     * &lt;/ul&gt;</span>
<span class="source-line-no">1250</span><span id="line-1250">     *</span>
<span class="source-line-no">1251</span><span id="line-1251">     * @param token               JWT token for which &lt;b&gt;signature was already validated&lt;/b&gt; and on which a set of additional validations will be applied.</span>
<span class="source-line-no">1252</span><span id="line-1252">     * @param expectedTokenType   The type of expected token using the enumeration provided.</span>
<span class="source-line-no">1253</span><span id="line-1253">     * @param revokedTokenJTIList A list of token identifier (&lt;b&gt;JTI&lt;/b&gt; claim) referring to tokens that were revoked and to which the JTI claim of the token will be compared to.</span>
<span class="source-line-no">1254</span><span id="line-1254">     * @return True only the token pass all the validations.</span>
<span class="source-line-no">1255</span><span id="line-1255">     * @see "https://www.iana.org/assignments/jwt/jwt.xhtml"</span>
<span class="source-line-no">1256</span><span id="line-1256">     * @see "https://auth0.com/docs/secure/tokens/access-tokens"</span>
<span class="source-line-no">1257</span><span id="line-1257">     * @see "https://auth0.com/docs/secure/tokens/id-tokens"</span>
<span class="source-line-no">1258</span><span id="line-1258">     * @see "https://auth0.com/docs/secure/tokens/refresh-tokens"</span>
<span class="source-line-no">1259</span><span id="line-1259">     * @see "https://auth0.com/blog/id-token-access-token-what-is-the-difference/"</span>
<span class="source-line-no">1260</span><span id="line-1260">     * @see "https://jwt.io/libraries?language=Java"</span>
<span class="source-line-no">1261</span><span id="line-1261">     * @see "https://pentesterlab.com/blog/secure-jwt-library-design"</span>
<span class="source-line-no">1262</span><span id="line-1262">     * @see "https://github.com/auth0/java-jwt"</span>
<span class="source-line-no">1263</span><span id="line-1263">     */</span>
<span class="source-line-no">1264</span><span id="line-1264">    public static boolean applyJWTExtraValidation(DecodedJWT token, TokenType expectedTokenType, List&lt;String&gt; revokedTokenJTIList) {</span>
<span class="source-line-no">1265</span><span id="line-1265">        boolean isValid = false;</span>
<span class="source-line-no">1266</span><span id="line-1266">        TokenType tokenType;</span>
<span class="source-line-no">1267</span><span id="line-1267">        try {</span>
<span class="source-line-no">1268</span><span id="line-1268">            if (!"none".equalsIgnoreCase(token.getAlgorithm().trim())) {</span>
<span class="source-line-no">1269</span><span id="line-1269">                if (!token.getClaim("exp").isMissing() &amp;&amp; token.getExpiresAt() != null) {</span>
<span class="source-line-no">1270</span><span id="line-1270">                    String jti = token.getId();</span>
<span class="source-line-no">1271</span><span id="line-1271">                    if (jti != null &amp;&amp; !jti.trim().isEmpty()) {</span>
<span class="source-line-no">1272</span><span id="line-1272">                        boolean jtiIsRevoked = revokedTokenJTIList.stream().anyMatch(jti::equalsIgnoreCase);</span>
<span class="source-line-no">1273</span><span id="line-1273">                        if (!jtiIsRevoked) {</span>
<span class="source-line-no">1274</span><span id="line-1274">                            //Determine the token type based on the presence of specifics claims</span>
<span class="source-line-no">1275</span><span id="line-1275">                            if (!token.getClaim("scope").isMissing()) {</span>
<span class="source-line-no">1276</span><span id="line-1276">                                tokenType = TokenType.ACCESS;</span>
<span class="source-line-no">1277</span><span id="line-1277">                            } else if (!token.getClaim("name").isMissing() || !token.getClaim("email").isMissing()) {</span>
<span class="source-line-no">1278</span><span id="line-1278">                                tokenType = TokenType.ID;</span>
<span class="source-line-no">1279</span><span id="line-1279">                            } else {</span>
<span class="source-line-no">1280</span><span id="line-1280">                                tokenType = TokenType.REFRESH;</span>
<span class="source-line-no">1281</span><span id="line-1281">                            }</span>
<span class="source-line-no">1282</span><span id="line-1282">                            isValid = (tokenType.equals(expectedTokenType));</span>
<span class="source-line-no">1283</span><span id="line-1283">                        }</span>
<span class="source-line-no">1284</span><span id="line-1284">                    }</span>
<span class="source-line-no">1285</span><span id="line-1285">                }</span>
<span class="source-line-no">1286</span><span id="line-1286">            }</span>
<span class="source-line-no">1287</span><span id="line-1287"></span>
<span class="source-line-no">1288</span><span id="line-1288">        } catch (Exception e) {</span>
<span class="source-line-no">1289</span><span id="line-1289">            //In case of error then assume that the check failed</span>
<span class="source-line-no">1290</span><span id="line-1290">            isValid = false;</span>
<span class="source-line-no">1291</span><span id="line-1291">        }</span>
<span class="source-line-no">1292</span><span id="line-1292">        return isValid;</span>
<span class="source-line-no">1293</span><span id="line-1293">    }</span>
<span class="source-line-no">1294</span><span id="line-1294"></span>
<span class="source-line-no">1295</span><span id="line-1295">    /**</span>
<span class="source-line-no">1296</span><span id="line-1296">     * Apply a validations on a regular expression to ensure that is not prone to the ReDOS attack.</span>
<span class="source-line-no">1297</span><span id="line-1297">     * &lt;br&gt;If your technology is supported by &lt;a href="https://github.com/doyensec/regexploit"&gt;regexploit&lt;/a&gt; then &lt;b&gt;use it instead of this method!&lt;/b&gt;</span>
<span class="source-line-no">1298</span><span id="line-1298">     * &lt;br&gt;Indeed, the &lt;a href="https://www.doyensec.com/"&gt;Doyensec&lt;/a&gt; team has made an intensive and amazing work on this topic and created this effective tool.</span>
<span class="source-line-no">1299</span><span id="line-1299">     *</span>
<span class="source-line-no">1300</span><span id="line-1300">     * @param regex                       String expected to be a valid regular expression (regex).</span>
<span class="source-line-no">1301</span><span id="line-1301">     * @param data                        Test data on which the regular expression is executed for the test.</span>
<span class="source-line-no">1302</span><span id="line-1302">     * @param maximumRunningTimeInSeconds Optional parameter to specify a number of seconds above which a regex execution time is considered as not safe (default to 4 seconds when not specified).</span>
<span class="source-line-no">1303</span><span id="line-1303">     * @return True only if the string pass all validations.</span>
<span class="source-line-no">1304</span><span id="line-1304">     * @see "https://github.blog/security/how-to-fix-a-redos/"</span>
<span class="source-line-no">1305</span><span id="line-1305">     * @see "https://learn.snyk.io/lesson/redos"</span>
<span class="source-line-no">1306</span><span id="line-1306">     * @see "https://rules.sonarsource.com/java/RSPEC-2631/"</span>
<span class="source-line-no">1307</span><span id="line-1307">     * @see "https://github.com/doyensec/regexploit"</span>
<span class="source-line-no">1308</span><span id="line-1308">     * @see "https://wiki.owasp.org/images/2/23/OWASP_IL_2009_ReDoS.pdf"</span>
<span class="source-line-no">1309</span><span id="line-1309">     * @see "https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS"</span>
<span class="source-line-no">1310</span><span id="line-1310">     */</span>
<span class="source-line-no">1311</span><span id="line-1311">    public static boolean isRegexSafe(String regex, String data, Optional&lt;Integer&gt; maximumRunningTimeInSeconds) {</span>
<span class="source-line-no">1312</span><span id="line-1312">        Objects.requireNonNull(maximumRunningTimeInSeconds, "Use 'Optional.empty()' to leverage the default value.");</span>
<span class="source-line-no">1313</span><span id="line-1313">        Objects.requireNonNull(data, "A sample data is needed to perform the test.");</span>
<span class="source-line-no">1314</span><span id="line-1314">        Objects.requireNonNull(regex, "A regular expression is needed to perform the test.");</span>
<span class="source-line-no">1315</span><span id="line-1315">        boolean isSafe = false;</span>
<span class="source-line-no">1316</span><span id="line-1316">        int executionTimeout = maximumRunningTimeInSeconds.orElse(4);</span>
<span class="source-line-no">1317</span><span id="line-1317">        ExecutorService executor = Executors.newSingleThreadExecutor();</span>
<span class="source-line-no">1318</span><span id="line-1318">        try {</span>
<span class="source-line-no">1319</span><span id="line-1319">            Callable&lt;Boolean&gt; task = () -&gt; {</span>
<span class="source-line-no">1320</span><span id="line-1320">                Pattern pattern = Pattern.compile(regex);</span>
<span class="source-line-no">1321</span><span id="line-1321">                return pattern.matcher(data).matches();</span>
<span class="source-line-no">1322</span><span id="line-1322">            };</span>
<span class="source-line-no">1323</span><span id="line-1323">            List&lt;Future&lt;Boolean&gt;&gt; tasks = executor.invokeAll(List.of(task), executionTimeout, TimeUnit.SECONDS);</span>
<span class="source-line-no">1324</span><span id="line-1324">            if (!tasks.getFirst().isCancelled()) {</span>
<span class="source-line-no">1325</span><span id="line-1325">                isSafe = true;</span>
<span class="source-line-no">1326</span><span id="line-1326">            }</span>
<span class="source-line-no">1327</span><span id="line-1327">        } catch (Exception e) {</span>
<span class="source-line-no">1328</span><span id="line-1328">            isSafe = false;</span>
<span class="source-line-no">1329</span><span id="line-1329">        } finally {</span>
<span class="source-line-no">1330</span><span id="line-1330">            executor.shutdownNow();</span>
<span class="source-line-no">1331</span><span id="line-1331">        }</span>
<span class="source-line-no">1332</span><span id="line-1332">        return isSafe;</span>
<span class="source-line-no">1333</span><span id="line-1333">    }</span>
<span class="source-line-no">1334</span><span id="line-1334"></span>
<span class="source-line-no">1335</span><span id="line-1335">    /**</span>
<span class="source-line-no">1336</span><span id="line-1336">     * Compute a UUID version 7 without using any external dependency.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">1337</span><span id="line-1337">     * &lt;b&gt;Below are my personal point of view and perhaps I'm totally wrong!&lt;/b&gt;</span>
<span class="source-line-no">1338</span><span id="line-1338">     * &lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">1339</span><span id="line-1339">     * Why such method?</span>
<span class="source-line-no">1340</span><span id="line-1340">     * &lt;ul&gt;</span>
<span class="source-line-no">1341</span><span id="line-1341">     * &lt;li&gt;Java inferior or equals to 21 does not supports natively the generation of an UUID version 7.&lt;/li&gt;</span>
<span class="source-line-no">1342</span><span id="line-1342">     * &lt;li&gt;Import a library just to generate such value is overkill for me.&lt;/li&gt;</span>
<span class="source-line-no">1343</span><span id="line-1343">     * &lt;li&gt;Library that I have found, generating such version of an UUID, are not provided by entities commonly used in the java world, such as the SPRING framework provider.&lt;/li&gt;</span>
<span class="source-line-no">1344</span><span id="line-1344">     * &lt;/ul&gt;</span>
<span class="source-line-no">1345</span><span id="line-1345">     * &lt;br&gt;</span>
<span class="source-line-no">1346</span><span id="line-1346">     * &lt;b&gt;Full credits for this implementation goes to the authors and contributors of the &lt;a href="https://github.com/nalgeon/uuidv7"&gt;UUIDv7&lt;/a&gt; project.&lt;/b&gt;</span>
<span class="source-line-no">1347</span><span id="line-1347">     * &lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">1348</span><span id="line-1348">     * Below are the java libraries that I have found but, for which, I do not trust enough the provider to use them directly:</span>
<span class="source-line-no">1349</span><span id="line-1349">     * &lt;ul&gt;</span>
<span class="source-line-no">1350</span><span id="line-1350">     *     &lt;li&gt;&lt;a href="https://github.com/cowtowncoder/java-uuid-generator"&gt;java-uuid-generator&lt;/a&gt;&lt;/li&gt;</span>
<span class="source-line-no">1351</span><span id="line-1351">     *     &lt;li&gt;&lt;a href="https://github.com/f4b6a3/uuid-creator"&gt;uuid-creator&lt;/a&gt;&lt;/li&gt;</span>
<span class="source-line-no">1352</span><span id="line-1352">     * &lt;/ul&gt;</span>
<span class="source-line-no">1353</span><span id="line-1353">     *</span>
<span class="source-line-no">1354</span><span id="line-1354">     * @return A UUID object representing the UUID v7.</span>
<span class="source-line-no">1355</span><span id="line-1355">     * @see "https://uuid7.com/"</span>
<span class="source-line-no">1356</span><span id="line-1356">     * @see "https://antonz.org/uuidv7/"</span>
<span class="source-line-no">1357</span><span id="line-1357">     * @see "https://mccue.dev/pages/3-11-25-life-altering-postgresql-patterns"</span>
<span class="source-line-no">1358</span><span id="line-1358">     * @see "https://www.ietf.org/archive/id/draft-peabody-dispatch-new-uuid-format-04.html#name-uuid-version-7"</span>
<span class="source-line-no">1359</span><span id="line-1359">     * @see "https://www.baeldung.com/java-generating-time-based-uuids"</span>
<span class="source-line-no">1360</span><span id="line-1360">     * @see "https://en.wikipedia.org/wiki/Universally_unique_identifier"</span>
<span class="source-line-no">1361</span><span id="line-1361">     * @see "https://buildkite.com/resources/blog/goodbye-integers-hello-uuids/"</span>
<span class="source-line-no">1362</span><span id="line-1362">     */</span>
<span class="source-line-no">1363</span><span id="line-1363">    public static UUID computeUUIDv7() {</span>
<span class="source-line-no">1364</span><span id="line-1364">        SecureRandom secureRandom = new SecureRandom();</span>
<span class="source-line-no">1365</span><span id="line-1365">        // Generate truly random bytes</span>
<span class="source-line-no">1366</span><span id="line-1366">        byte[] value = new byte[16];</span>
<span class="source-line-no">1367</span><span id="line-1367">        secureRandom.nextBytes(value);</span>
<span class="source-line-no">1368</span><span id="line-1368">        // Get current timestamp in milliseconds</span>
<span class="source-line-no">1369</span><span id="line-1369">        ByteBuffer timestamp = ByteBuffer.allocate(Long.BYTES);</span>
<span class="source-line-no">1370</span><span id="line-1370">        timestamp.putLong(System.currentTimeMillis());</span>
<span class="source-line-no">1371</span><span id="line-1371">        // Create the TIMESTAMP part of the UUID</span>
<span class="source-line-no">1372</span><span id="line-1372">        System.arraycopy(timestamp.array(), 2, value, 0, 6);</span>
<span class="source-line-no">1373</span><span id="line-1373">        // Create the VERSION and the VARIANT parts of the UUID</span>
<span class="source-line-no">1374</span><span id="line-1374">        value[6] = (byte) ((value[6] &amp; 0x0F) | 0x70);</span>
<span class="source-line-no">1375</span><span id="line-1375">        value[8] = (byte) ((value[8] &amp; 0x3F) | 0x80);</span>
<span class="source-line-no">1376</span><span id="line-1376">        //Create the HIGH and LOW parts of the UUID</span>
<span class="source-line-no">1377</span><span id="line-1377">        ByteBuffer buf = ByteBuffer.wrap(value);</span>
<span class="source-line-no">1378</span><span id="line-1378">        long high = buf.getLong();</span>
<span class="source-line-no">1379</span><span id="line-1379">        long low = buf.getLong();</span>
<span class="source-line-no">1380</span><span id="line-1380">        //Create and return the UUID object</span>
<span class="source-line-no">1381</span><span id="line-1381">        UUID uuidv7 = new UUID(high, low);</span>
<span class="source-line-no">1382</span><span id="line-1382">        return uuidv7;</span>
<span class="source-line-no">1383</span><span id="line-1383">    }</span>
<span class="source-line-no">1384</span><span id="line-1384"></span>
<span class="source-line-no">1385</span><span id="line-1385">    /**</span>
<span class="source-line-no">1386</span><span id="line-1386">     * Ensure that an XSD file does not contain any include/import/redefine instruction (prevent exposure to SSRF).</span>
<span class="source-line-no">1387</span><span id="line-1387">     *</span>
<span class="source-line-no">1388</span><span id="line-1388">     * @param xsdFilePath Filename of the XSD file to check.</span>
<span class="source-line-no">1389</span><span id="line-1389">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">1390</span><span id="line-1390">     * @see "https://portswigger.net/web-security/ssrf"</span>
<span class="source-line-no">1391</span><span id="line-1391">     * @see "https://www.w3schools.com/Xml/el_import.asp"</span>
<span class="source-line-no">1392</span><span id="line-1392">     * @see "https://www.w3schools.com/xml/el_include.asp"</span>
<span class="source-line-no">1393</span><span id="line-1393">     * @see "https://www.linkedin.com/posts/righettod_appsec-appsecurity-java-activity-7344048434326188053-6Ru9"</span>
<span class="source-line-no">1394</span><span id="line-1394">     * @see "https://docs.oracle.com/en/java/javase/21/docs/api/java.xml/javax/xml/validation/SchemaFactory.html#setProperty(java.lang.String,java.lang.Object)"</span>
<span class="source-line-no">1395</span><span id="line-1395">     */</span>
<span class="source-line-no">1396</span><span id="line-1396">    public static boolean isXSDSafe(String xsdFilePath) {</span>
<span class="source-line-no">1397</span><span id="line-1397">        boolean isSafe = false;</span>
<span class="source-line-no">1398</span><span id="line-1398">        try {</span>
<span class="source-line-no">1399</span><span id="line-1399">            File xsdFile = new File(xsdFilePath);</span>
<span class="source-line-no">1400</span><span id="line-1400">            if (xsdFile.exists() &amp;&amp; xsdFile.canRead() &amp;&amp; xsdFile.isFile()) {</span>
<span class="source-line-no">1401</span><span id="line-1401">                //Parse the XSD file, if an exception occur then it's imply that the XSD specified is not a valid ones</span>
<span class="source-line-no">1402</span><span id="line-1402">                //Create an schema factory throwing Exception if a external schema is specified</span>
<span class="source-line-no">1403</span><span id="line-1403">                SchemaFactory schemaFactory = SchemaFactory.newDefaultInstance();</span>
<span class="source-line-no">1404</span><span id="line-1404">                schemaFactory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, "");</span>
<span class="source-line-no">1405</span><span id="line-1405">                schemaFactory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, "");</span>
<span class="source-line-no">1406</span><span id="line-1406">                //Parse the schema</span>
<span class="source-line-no">1407</span><span id="line-1407">                Schema schema = schemaFactory.newSchema(xsdFile);</span>
<span class="source-line-no">1408</span><span id="line-1408">                isSafe = (schema != null);</span>
<span class="source-line-no">1409</span><span id="line-1409">            }</span>
<span class="source-line-no">1410</span><span id="line-1410">        } catch (Exception e) {</span>
<span class="source-line-no">1411</span><span id="line-1411">            isSafe = false;</span>
<span class="source-line-no">1412</span><span id="line-1412">        }</span>
<span class="source-line-no">1413</span><span id="line-1413">        return isSafe;</span>
<span class="source-line-no">1414</span><span id="line-1414">    }</span>
<span class="source-line-no">1415</span><span id="line-1415">}</span>




























































</pre>
</div>
</main>
</body>
</html>
