<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (21) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: eu.righettod, class: SecurityUtils">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">package eu.righettod;</span>
<span class="source-line-no">002</span><span id="line-2"></span>
<span class="source-line-no">003</span><span id="line-3">import org.apache.commons.csv.CSVFormat;</span>
<span class="source-line-no">004</span><span id="line-4">import org.apache.commons.csv.CSVRecord;</span>
<span class="source-line-no">005</span><span id="line-5">import org.apache.commons.validator.routines.InetAddressValidator;</span>
<span class="source-line-no">006</span><span id="line-6">import org.apache.pdfbox.Loader;</span>
<span class="source-line-no">007</span><span id="line-7">import org.apache.pdfbox.pdmodel.PDDocument;</span>
<span class="source-line-no">008</span><span id="line-8">import org.apache.pdfbox.pdmodel.PDDocumentCatalog;</span>
<span class="source-line-no">009</span><span id="line-9">import org.apache.pdfbox.pdmodel.PDDocumentInformation;</span>
<span class="source-line-no">010</span><span id="line-10">import org.apache.pdfbox.pdmodel.PDDocumentNameDictionary;</span>
<span class="source-line-no">011</span><span id="line-11">import org.apache.pdfbox.pdmodel.common.PDMetadata;</span>
<span class="source-line-no">012</span><span id="line-12">import org.apache.pdfbox.pdmodel.interactive.action.*;</span>
<span class="source-line-no">013</span><span id="line-13">import org.apache.pdfbox.pdmodel.interactive.annotation.AnnotationFilter;</span>
<span class="source-line-no">014</span><span id="line-14">import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotation;</span>
<span class="source-line-no">015</span><span id="line-15">import org.apache.pdfbox.pdmodel.interactive.annotation.PDAnnotationLink;</span>
<span class="source-line-no">016</span><span id="line-16">import org.apache.poi.poifs.filesystem.DirectoryEntry;</span>
<span class="source-line-no">017</span><span id="line-17">import org.apache.poi.poifs.filesystem.POIFSFileSystem;</span>
<span class="source-line-no">018</span><span id="line-18">import org.apache.poi.poifs.macros.VBAMacroReader;</span>
<span class="source-line-no">019</span><span id="line-19">import org.apache.tika.detect.DefaultDetector;</span>
<span class="source-line-no">020</span><span id="line-20">import org.apache.tika.detect.Detector;</span>
<span class="source-line-no">021</span><span id="line-21">import org.apache.tika.io.TemporaryResources;</span>
<span class="source-line-no">022</span><span id="line-22">import org.apache.tika.io.TikaInputStream;</span>
<span class="source-line-no">023</span><span id="line-23">import org.apache.tika.metadata.Metadata;</span>
<span class="source-line-no">024</span><span id="line-24">import org.apache.tika.mime.MediaType;</span>
<span class="source-line-no">025</span><span id="line-25">import org.apache.tika.mime.MimeTypes;</span>
<span class="source-line-no">026</span><span id="line-26">import org.w3c.dom.Document;</span>
<span class="source-line-no">027</span><span id="line-27">import org.xml.sax.EntityResolver;</span>
<span class="source-line-no">028</span><span id="line-28">import org.xml.sax.InputSource;</span>
<span class="source-line-no">029</span><span id="line-29">import org.xml.sax.SAXException;</span>
<span class="source-line-no">030</span><span id="line-30"></span>
<span class="source-line-no">031</span><span id="line-31">import javax.crypto.Mac;</span>
<span class="source-line-no">032</span><span id="line-32">import javax.crypto.spec.SecretKeySpec;</span>
<span class="source-line-no">033</span><span id="line-33">import javax.xml.parsers.DocumentBuilder;</span>
<span class="source-line-no">034</span><span id="line-34">import javax.xml.parsers.DocumentBuilderFactory;</span>
<span class="source-line-no">035</span><span id="line-35">import javax.xml.parsers.ParserConfigurationException;</span>
<span class="source-line-no">036</span><span id="line-36">import java.io.*;</span>
<span class="source-line-no">037</span><span id="line-37">import java.net.Inet6Address;</span>
<span class="source-line-no">038</span><span id="line-38">import java.net.InetAddress;</span>
<span class="source-line-no">039</span><span id="line-39">import java.net.MalformedURLException;</span>
<span class="source-line-no">040</span><span id="line-40">import java.net.URL;</span>
<span class="source-line-no">041</span><span id="line-41">import java.nio.charset.StandardCharsets;</span>
<span class="source-line-no">042</span><span id="line-42">import java.nio.file.Files;</span>
<span class="source-line-no">043</span><span id="line-43">import java.security.MessageDigest;</span>
<span class="source-line-no">044</span><span id="line-44">import java.util.*;</span>
<span class="source-line-no">045</span><span id="line-45">import java.util.concurrent.atomic.AtomicInteger;</span>
<span class="source-line-no">046</span><span id="line-46">import java.util.regex.Pattern;</span>
<span class="source-line-no">047</span><span id="line-47">import java.util.zip.ZipEntry;</span>
<span class="source-line-no">048</span><span id="line-48">import java.util.zip.ZipFile;</span>
<span class="source-line-no">049</span><span id="line-49"></span>
<span class="source-line-no">050</span><span id="line-50">/**</span>
<span class="source-line-no">051</span><span id="line-51"> * Provides different utilities methods to apply processing from a security perspective.&lt;br&gt;</span>
<span class="source-line-no">052</span><span id="line-52"> * These code snippet:</span>
<span class="source-line-no">053</span><span id="line-53"> * &lt;ul&gt;</span>
<span class="source-line-no">054</span><span id="line-54"> *     &lt;li&gt;Can be used, as "foundation", to customize the validation to the app context.&lt;/li&gt;</span>
<span class="source-line-no">055</span><span id="line-55"> *     &lt;li&gt;Were implemented in a way to facilitate adding or removal of validations depending on usage context.&lt;/li&gt;</span>
<span class="source-line-no">056</span><span id="line-56"> *     &lt;li&gt;Were centralized on one class to be able to enhance them across time as well as &lt;a href="https://github.com/righettod/code-snippets-security-utils/issues"&gt;missing case/bug identification&lt;/a&gt;.&lt;/li&gt;</span>
<span class="source-line-no">057</span><span id="line-57"> * &lt;/ul&gt;</span>
<span class="source-line-no">058</span><span id="line-58"> */</span>
<span class="source-line-no">059</span><span id="line-59">public class SecurityUtils {</span>
<span class="source-line-no">060</span><span id="line-60"></span>
<span class="source-line-no">061</span><span id="line-61">    /**</span>
<span class="source-line-no">062</span><span id="line-62">     * Default constructor: Not needed as the class only provides static methods.</span>
<span class="source-line-no">063</span><span id="line-63">     */</span>
<span class="source-line-no">064</span><span id="line-64">    private SecurityUtils() {</span>
<span class="source-line-no">065</span><span id="line-65">    }</span>
<span class="source-line-no">066</span><span id="line-66"></span>
<span class="source-line-no">067</span><span id="line-67">    /**</span>
<span class="source-line-no">068</span><span id="line-68">     * Apply a collection of validation to verify if a provided PIN code is considered weak (easy to guess) or none.&lt;br&gt;</span>
<span class="source-line-no">069</span><span id="line-69">     * This method consider that format of the PIN code is [0-9]{6,}&lt;br&gt;</span>
<span class="source-line-no">070</span><span id="line-70">     * Rule to consider a PIN code as weak:&lt;br&gt;</span>
<span class="source-line-no">071</span><span id="line-71">     * - Length is inferior to 6 positions.&lt;br&gt;</span>
<span class="source-line-no">072</span><span id="line-72">     * - Contain only the same number or only a sequence of zero.&lt;br&gt;</span>
<span class="source-line-no">073</span><span id="line-73">     * - Contain sequence of following incremental or decremental numbers.&lt;br&gt;</span>
<span class="source-line-no">074</span><span id="line-74">     *</span>
<span class="source-line-no">075</span><span id="line-75">     * @param pinCode PIN code to verify.</span>
<span class="source-line-no">076</span><span id="line-76">     * @return True only if the PIN is considered as weak.</span>
<span class="source-line-no">077</span><span id="line-77">     */</span>
<span class="source-line-no">078</span><span id="line-78">    public static boolean isWeakPINCode(String pinCode) {</span>
<span class="source-line-no">079</span><span id="line-79">        boolean isWeak = true;</span>
<span class="source-line-no">080</span><span id="line-80">        //Length is inferior to 6 positions</span>
<span class="source-line-no">081</span><span id="line-81">        //Use "Long.parseLong(pinCode)" to cause a NumberFormatException if the PIN is not a numeric one</span>
<span class="source-line-no">082</span><span id="line-82">        //and to ensure that the PIN is not only a sequence of zero</span>
<span class="source-line-no">083</span><span id="line-83">        if (pinCode != null &amp;&amp; Long.parseLong(pinCode) &gt; 0 &amp;&amp; pinCode.trim().length() &gt; 5) {</span>
<span class="source-line-no">084</span><span id="line-84">            //Contain only the same number</span>
<span class="source-line-no">085</span><span id="line-85">            String regex = String.format("^[%s]{%s}$", pinCode.charAt(0), pinCode.length());</span>
<span class="source-line-no">086</span><span id="line-86">            if (!Pattern.matches(regex, pinCode)) {</span>
<span class="source-line-no">087</span><span id="line-87">                //Contain sequence of following incremental or decremental numbers</span>
<span class="source-line-no">088</span><span id="line-88">                char previousChar = 'X';</span>
<span class="source-line-no">089</span><span id="line-89">                boolean containSequence = false;</span>
<span class="source-line-no">090</span><span id="line-90">                for (char c : pinCode.toCharArray()) {</span>
<span class="source-line-no">091</span><span id="line-91">                    if (previousChar != 'X') {</span>
<span class="source-line-no">092</span><span id="line-92">                        int previousNbr = Integer.parseInt(String.valueOf(previousChar));</span>
<span class="source-line-no">093</span><span id="line-93">                        int currentNbr = Integer.parseInt(String.valueOf(c));</span>
<span class="source-line-no">094</span><span id="line-94">                        if (currentNbr == (previousNbr - 1) || currentNbr == (previousNbr + 1)) {</span>
<span class="source-line-no">095</span><span id="line-95">                            containSequence = true;</span>
<span class="source-line-no">096</span><span id="line-96">                            break;</span>
<span class="source-line-no">097</span><span id="line-97">                        }</span>
<span class="source-line-no">098</span><span id="line-98">                    }</span>
<span class="source-line-no">099</span><span id="line-99">                    previousChar = c;</span>
<span class="source-line-no">100</span><span id="line-100">                }</span>
<span class="source-line-no">101</span><span id="line-101">                if (!containSequence) {</span>
<span class="source-line-no">102</span><span id="line-102">                    isWeak = false;</span>
<span class="source-line-no">103</span><span id="line-103">                }</span>
<span class="source-line-no">104</span><span id="line-104">            }</span>
<span class="source-line-no">105</span><span id="line-105">        }</span>
<span class="source-line-no">106</span><span id="line-106">        return isWeak;</span>
<span class="source-line-no">107</span><span id="line-107">    }</span>
<span class="source-line-no">108</span><span id="line-108"></span>
<span class="source-line-no">109</span><span id="line-109">    /**</span>
<span class="source-line-no">110</span><span id="line-110">     * Apply a collection of validations on a Word 97-2003 (binary format) document file provided:&lt;br&gt;</span>
<span class="source-line-no">111</span><span id="line-111">     * - Real Microsoft Word 97-2003 document file.&lt;br&gt;</span>
<span class="source-line-no">112</span><span id="line-112">     * - No VBA Macro.&lt;br&gt;</span>
<span class="source-line-no">113</span><span id="line-113">     * - No embedded objects.&lt;br&gt;</span>
<span class="source-line-no">114</span><span id="line-114">     *</span>
<span class="source-line-no">115</span><span id="line-115">     * @param wordFilePath Filename of the Word document file to check.</span>
<span class="source-line-no">116</span><span id="line-116">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">117</span><span id="line-117">     * @see "https://poi.apache.org/components/"</span>
<span class="source-line-no">118</span><span id="line-118">     * @see "https://poi.apache.org/components/document/"</span>
<span class="source-line-no">119</span><span id="line-119">     * @see "https://poi.apache.org/components/poifs/how-to.html"</span>
<span class="source-line-no">120</span><span id="line-120">     * @see "https://poi.apache.org/components/poifs/embeded.html"</span>
<span class="source-line-no">121</span><span id="line-121">     * @see "https://poi.apache.org/"</span>
<span class="source-line-no">122</span><span id="line-122">     * @see "https://mvnrepository.com/artifact/org.apache.poi/poi"</span>
<span class="source-line-no">123</span><span id="line-123">     */</span>
<span class="source-line-no">124</span><span id="line-124">    public static boolean isWord972003DocumentSafe(String wordFilePath) {</span>
<span class="source-line-no">125</span><span id="line-125">        boolean isSafe = false;</span>
<span class="source-line-no">126</span><span id="line-126">        try {</span>
<span class="source-line-no">127</span><span id="line-127">            File wordFile = new File(wordFilePath);</span>
<span class="source-line-no">128</span><span id="line-128">            if (wordFile.exists() &amp;&amp; wordFile.canRead() &amp;&amp; wordFile.isFile()) {</span>
<span class="source-line-no">129</span><span id="line-129">                //Step 1: Try to load the file, if its fail then it imply that is not a valid Word 97-2003 format file</span>
<span class="source-line-no">130</span><span id="line-130">                try (POIFSFileSystem fs = new POIFSFileSystem(wordFile)) {</span>
<span class="source-line-no">131</span><span id="line-131">                    //Step 2: Check if the document contains VBA macros, in our case is not allowed</span>
<span class="source-line-no">132</span><span id="line-132">                    VBAMacroReader macroReader = new VBAMacroReader(fs);</span>
<span class="source-line-no">133</span><span id="line-133">                    Map&lt;String, String&gt; macros = macroReader.readMacros();</span>
<span class="source-line-no">134</span><span id="line-134">                    if (macros == null || macros.isEmpty()) {</span>
<span class="source-line-no">135</span><span id="line-135">                        //Step 3: Check if the document contains any embedded objects, in our case is not allowed</span>
<span class="source-line-no">136</span><span id="line-136">                        //From POI documentation:</span>
<span class="source-line-no">137</span><span id="line-137">                        //Word normally stores embedded files in subdirectories of the ObjectPool directory, itself a subdirectory of the filesystem root.</span>
<span class="source-line-no">138</span><span id="line-138">                        //Typically, these subdirectories and named starting with an underscore, followed by 10 numbers.</span>
<span class="source-line-no">139</span><span id="line-139">                        final List&lt;String&gt; embeddedObjectFound = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">140</span><span id="line-140">                        DirectoryEntry root = fs.getRoot();</span>
<span class="source-line-no">141</span><span id="line-141">                        if (root.getEntryCount() &gt; 0) {</span>
<span class="source-line-no">142</span><span id="line-142">                            root.iterator().forEachRemaining(entry -&gt; {</span>
<span class="source-line-no">143</span><span id="line-143">                                if ("ObjectPool".equalsIgnoreCase(entry.getName()) &amp;&amp; entry instanceof DirectoryEntry) {</span>
<span class="source-line-no">144</span><span id="line-144">                                    DirectoryEntry objPoolDirectory = (DirectoryEntry) entry;</span>
<span class="source-line-no">145</span><span id="line-145">                                    if (objPoolDirectory.getEntryCount() &gt; 0) {</span>
<span class="source-line-no">146</span><span id="line-146">                                        objPoolDirectory.iterator().forEachRemaining(objPoolDirectoryEntry -&gt; {</span>
<span class="source-line-no">147</span><span id="line-147">                                            if (objPoolDirectoryEntry instanceof DirectoryEntry) {</span>
<span class="source-line-no">148</span><span id="line-148">                                                DirectoryEntry objPoolDirectoryEntrySubDirectoryEntry = (DirectoryEntry) objPoolDirectoryEntry;</span>
<span class="source-line-no">149</span><span id="line-149">                                                if (objPoolDirectoryEntrySubDirectoryEntry.getEntryCount() &gt; 0) {</span>
<span class="source-line-no">150</span><span id="line-150">                                                    objPoolDirectoryEntrySubDirectoryEntry.forEach(objPoolDirectoryEntrySubDirectoryEntryEntry -&gt; {</span>
<span class="source-line-no">151</span><span id="line-151">                                                        if (objPoolDirectoryEntrySubDirectoryEntryEntry.isDocumentEntry()) {</span>
<span class="source-line-no">152</span><span id="line-152">                                                            embeddedObjectFound.add(objPoolDirectoryEntrySubDirectoryEntryEntry.getName());</span>
<span class="source-line-no">153</span><span id="line-153">                                                        }</span>
<span class="source-line-no">154</span><span id="line-154">                                                    });</span>
<span class="source-line-no">155</span><span id="line-155">                                                }</span>
<span class="source-line-no">156</span><span id="line-156">                                            }</span>
<span class="source-line-no">157</span><span id="line-157">                                        });</span>
<span class="source-line-no">158</span><span id="line-158">                                    }</span>
<span class="source-line-no">159</span><span id="line-159">                                }</span>
<span class="source-line-no">160</span><span id="line-160">                            });</span>
<span class="source-line-no">161</span><span id="line-161">                        }</span>
<span class="source-line-no">162</span><span id="line-162">                        isSafe = embeddedObjectFound.isEmpty();</span>
<span class="source-line-no">163</span><span id="line-163">                    }</span>
<span class="source-line-no">164</span><span id="line-164">                }</span>
<span class="source-line-no">165</span><span id="line-165">            }</span>
<span class="source-line-no">166</span><span id="line-166">        } catch (Exception e) {</span>
<span class="source-line-no">167</span><span id="line-167">            isSafe = false;</span>
<span class="source-line-no">168</span><span id="line-168">        }</span>
<span class="source-line-no">169</span><span id="line-169">        return isSafe;</span>
<span class="source-line-no">170</span><span id="line-170">    }</span>
<span class="source-line-no">171</span><span id="line-171"></span>
<span class="source-line-no">172</span><span id="line-172">    /**</span>
<span class="source-line-no">173</span><span id="line-173">     * Ensure that an XML file does not contain any External Entity, DTD or XInclude instructions.</span>
<span class="source-line-no">174</span><span id="line-174">     *</span>
<span class="source-line-no">175</span><span id="line-175">     * @param xmlFilePath Filename of the XML file to check.</span>
<span class="source-line-no">176</span><span id="line-176">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">177</span><span id="line-177">     * @see "https://portswigger.net/web-security/xxe"</span>
<span class="source-line-no">178</span><span id="line-178">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java"</span>
<span class="source-line-no">179</span><span id="line-179">     * @see "https://docs.oracle.com/en/java/javase/13/security/java-api-xml-processing-jaxp-security-guide.html#GUID-82F8C206-F2DF-4204-9544-F96155B1D258"</span>
<span class="source-line-no">180</span><span id="line-180">     * @see "https://www.w3.org/TR/xinclude-11/"</span>
<span class="source-line-no">181</span><span id="line-181">     * @see "https://en.wikipedia.org/wiki/XInclude"</span>
<span class="source-line-no">182</span><span id="line-182">     */</span>
<span class="source-line-no">183</span><span id="line-183">    public static boolean isXMLSafe(String xmlFilePath) {</span>
<span class="source-line-no">184</span><span id="line-184">        boolean isSafe = false;</span>
<span class="source-line-no">185</span><span id="line-185">        try {</span>
<span class="source-line-no">186</span><span id="line-186">            File xmlFile = new File(xmlFilePath);</span>
<span class="source-line-no">187</span><span id="line-187">            if (xmlFile.exists() &amp;&amp; xmlFile.canRead() &amp;&amp; xmlFile.isFile()) {</span>
<span class="source-line-no">188</span><span id="line-188">                //Step 1a: Verify that the XML file content does not contain any XInclude instructions</span>
<span class="source-line-no">189</span><span id="line-189">                boolean containXInclude = Files.readAllLines(xmlFile.toPath()).stream().anyMatch(line -&gt; line.toLowerCase(Locale.ROOT).contains(":include "));</span>
<span class="source-line-no">190</span><span id="line-190">                if (!containXInclude) {</span>
<span class="source-line-no">191</span><span id="line-191">                    //Step 1b: Parse the XML file, if an exception occur than it's imply that the XML specified is not a valid ones</span>
<span class="source-line-no">192</span><span id="line-192">                    //Create an XML document builder throwing Exception if a DOCTYPE instruction is present</span>
<span class="source-line-no">193</span><span id="line-193">                    DocumentBuilderFactory dbfInstance = DocumentBuilderFactory.newInstance();</span>
<span class="source-line-no">194</span><span id="line-194">                    dbfInstance.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);</span>
<span class="source-line-no">195</span><span id="line-195">                    //Xerces 2 only</span>
<span class="source-line-no">196</span><span id="line-196">                    //dbfInstance.setFeature("http://xerces.apache.org/xerces2-j/features.html#disallow-doctype-decl",true);</span>
<span class="source-line-no">197</span><span id="line-197">                    dbfInstance.setXIncludeAware(false);</span>
<span class="source-line-no">198</span><span id="line-198">                    DocumentBuilder builder = dbfInstance.newDocumentBuilder();</span>
<span class="source-line-no">199</span><span id="line-199">                    //Parse the document</span>
<span class="source-line-no">200</span><span id="line-200">                    Document doc = builder.parse(xmlFile);</span>
<span class="source-line-no">201</span><span id="line-201">                    isSafe = (doc != null &amp;&amp; doc.getDocumentElement() != null);</span>
<span class="source-line-no">202</span><span id="line-202">                }</span>
<span class="source-line-no">203</span><span id="line-203">            }</span>
<span class="source-line-no">204</span><span id="line-204">        } catch (Exception e) {</span>
<span class="source-line-no">205</span><span id="line-205">            isSafe = false;</span>
<span class="source-line-no">206</span><span id="line-206">        }</span>
<span class="source-line-no">207</span><span id="line-207">        return isSafe;</span>
<span class="source-line-no">208</span><span id="line-208">    }</span>
<span class="source-line-no">209</span><span id="line-209"></span>
<span class="source-line-no">210</span><span id="line-210"></span>
<span class="source-line-no">211</span><span id="line-211">    /**</span>
<span class="source-line-no">212</span><span id="line-212">     * Extract all URL links from a PDF file provided.&lt;br&gt;</span>
<span class="source-line-no">213</span><span id="line-213">     * This can be used to apply validation on a PDF against contained links.</span>
<span class="source-line-no">214</span><span id="line-214">     *</span>
<span class="source-line-no">215</span><span id="line-215">     * @param pdfFilePath pdfFilePath Filename of the PDF file to process.</span>
<span class="source-line-no">216</span><span id="line-216">     * @return A List of URL objects that is empty if no links is found.</span>
<span class="source-line-no">217</span><span id="line-217">     * @throws Exception If any error occurs during the processing of the PDF file.</span>
<span class="source-line-no">218</span><span id="line-218">     * @see "https://www.gushiciku.cn/pl/21KQ"</span>
<span class="source-line-no">219</span><span id="line-219">     * @see "https://pdfbox.apache.org/"</span>
<span class="source-line-no">220</span><span id="line-220">     * @see "https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox"</span>
<span class="source-line-no">221</span><span id="line-221">     */</span>
<span class="source-line-no">222</span><span id="line-222">    public static List&lt;URL&gt; extractAllPDFLinks(String pdfFilePath) throws Exception {</span>
<span class="source-line-no">223</span><span id="line-223">        final List&lt;URL&gt; links = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">224</span><span id="line-224">        File pdfFile = new File(pdfFilePath);</span>
<span class="source-line-no">225</span><span id="line-225">        try (PDDocument document = Loader.loadPDF(pdfFile)) {</span>
<span class="source-line-no">226</span><span id="line-226">            PDDocumentCatalog documentCatalog = document.getDocumentCatalog();</span>
<span class="source-line-no">227</span><span id="line-227">            AnnotationFilter actionURIAnnotationFilter = new AnnotationFilter() {</span>
<span class="source-line-no">228</span><span id="line-228">                @Override</span>
<span class="source-line-no">229</span><span id="line-229">                public boolean accept(PDAnnotation annotation) {</span>
<span class="source-line-no">230</span><span id="line-230">                    boolean keep = false;</span>
<span class="source-line-no">231</span><span id="line-231">                    if (annotation instanceof PDAnnotationLink) {</span>
<span class="source-line-no">232</span><span id="line-232">                        keep = (((PDAnnotationLink) annotation).getAction() instanceof PDActionURI);</span>
<span class="source-line-no">233</span><span id="line-233">                    }</span>
<span class="source-line-no">234</span><span id="line-234">                    return keep;</span>
<span class="source-line-no">235</span><span id="line-235">                }</span>
<span class="source-line-no">236</span><span id="line-236">            };</span>
<span class="source-line-no">237</span><span id="line-237">            documentCatalog.getPages().forEach(page -&gt; {</span>
<span class="source-line-no">238</span><span id="line-238">                try {</span>
<span class="source-line-no">239</span><span id="line-239">                    page.getAnnotations(actionURIAnnotationFilter).forEach(annotation -&gt; {</span>
<span class="source-line-no">240</span><span id="line-240">                        PDActionURI linkAnnotation = (PDActionURI) ((PDAnnotationLink) annotation).getAction();</span>
<span class="source-line-no">241</span><span id="line-241">                        try {</span>
<span class="source-line-no">242</span><span id="line-242">                            URL urlObj = new URL(linkAnnotation.getURI());</span>
<span class="source-line-no">243</span><span id="line-243">                            if (!links.contains(urlObj)) {</span>
<span class="source-line-no">244</span><span id="line-244">                                links.add(urlObj);</span>
<span class="source-line-no">245</span><span id="line-245">                            }</span>
<span class="source-line-no">246</span><span id="line-246">                        } catch (MalformedURLException e) {</span>
<span class="source-line-no">247</span><span id="line-247">                            throw new RuntimeException(e);</span>
<span class="source-line-no">248</span><span id="line-248">                        }</span>
<span class="source-line-no">249</span><span id="line-249">                    });</span>
<span class="source-line-no">250</span><span id="line-250">                } catch (Exception e) {</span>
<span class="source-line-no">251</span><span id="line-251">                    throw new RuntimeException(e);</span>
<span class="source-line-no">252</span><span id="line-252">                }</span>
<span class="source-line-no">253</span><span id="line-253">            });</span>
<span class="source-line-no">254</span><span id="line-254">        }</span>
<span class="source-line-no">255</span><span id="line-255">        return links;</span>
<span class="source-line-no">256</span><span id="line-256">    }</span>
<span class="source-line-no">257</span><span id="line-257"></span>
<span class="source-line-no">258</span><span id="line-258">    /**</span>
<span class="source-line-no">259</span><span id="line-259">     * Apply a collection of validations on a PDF file provided:&lt;br&gt;</span>
<span class="source-line-no">260</span><span id="line-260">     * - Real PDF file&lt;br&gt;</span>
<span class="source-line-no">261</span><span id="line-261">     * - No attachments.&lt;br&gt;</span>
<span class="source-line-no">262</span><span id="line-262">     * - No Javascript code.&lt;br&gt;</span>
<span class="source-line-no">263</span><span id="line-263">     * - No links using action of type URI/Launch/RemoteGoTo/ImportData.&lt;br&gt;</span>
<span class="source-line-no">264</span><span id="line-264">     *</span>
<span class="source-line-no">265</span><span id="line-265">     * @param pdfFilePath Filename of the PDF file to check.</span>
<span class="source-line-no">266</span><span id="line-266">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">267</span><span id="line-267">     * @see "https://stackoverflow.com/a/36161267"</span>
<span class="source-line-no">268</span><span id="line-268">     * @see "https://www.gushiciku.cn/pl/21KQ"</span>
<span class="source-line-no">269</span><span id="line-269">     * @see "https://github.com/jonaslejon/malicious-pdf"</span>
<span class="source-line-no">270</span><span id="line-270">     * @see "https://pdfbox.apache.org/"</span>
<span class="source-line-no">271</span><span id="line-271">     * @see "https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox"</span>
<span class="source-line-no">272</span><span id="line-272">     */</span>
<span class="source-line-no">273</span><span id="line-273">    public static boolean isPDFSafe(String pdfFilePath) {</span>
<span class="source-line-no">274</span><span id="line-274">        boolean isSafe = false;</span>
<span class="source-line-no">275</span><span id="line-275">        try {</span>
<span class="source-line-no">276</span><span id="line-276">            File pdfFile = new File(pdfFilePath);</span>
<span class="source-line-no">277</span><span id="line-277">            if (pdfFile.exists() &amp;&amp; pdfFile.canRead() &amp;&amp; pdfFile.isFile()) {</span>
<span class="source-line-no">278</span><span id="line-278">                //Step 1: Try to load the file, if its fail then it imply that is not a valid PDF file</span>
<span class="source-line-no">279</span><span id="line-279">                try (PDDocument document = Loader.loadPDF(pdfFile)) {</span>
<span class="source-line-no">280</span><span id="line-280">                    //Step 2: Check if the file contains attached files, in our case is not allowed</span>
<span class="source-line-no">281</span><span id="line-281">                    PDDocumentCatalog documentCatalog = document.getDocumentCatalog();</span>
<span class="source-line-no">282</span><span id="line-282">                    PDDocumentNameDictionary namesDictionary = new PDDocumentNameDictionary(documentCatalog);</span>
<span class="source-line-no">283</span><span id="line-283">                    if (namesDictionary.getEmbeddedFiles() == null) {</span>
<span class="source-line-no">284</span><span id="line-284">                        //Step 3: Check if the file contains Javascript code, in our case is not allowed</span>
<span class="source-line-no">285</span><span id="line-285">                        if (namesDictionary.getJavaScript() == null) {</span>
<span class="source-line-no">286</span><span id="line-286">                            //Step 4: Check if the file contains links using action of type URI/Launch/RemoteGoTo/ImportData, in our case is not allowed</span>
<span class="source-line-no">287</span><span id="line-287">                            final List&lt;Integer&gt; notAllowedAnnotationCounterList = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">288</span><span id="line-288">                            AnnotationFilter notAllowedAnnotationFilter = new AnnotationFilter() {</span>
<span class="source-line-no">289</span><span id="line-289">                                @Override</span>
<span class="source-line-no">290</span><span id="line-290">                                public boolean accept(PDAnnotation annotation) {</span>
<span class="source-line-no">291</span><span id="line-291">                                    boolean keep = false;</span>
<span class="source-line-no">292</span><span id="line-292">                                    if (annotation instanceof PDAnnotationLink) {</span>
<span class="source-line-no">293</span><span id="line-293">                                        PDAnnotationLink link = (PDAnnotationLink) annotation;</span>
<span class="source-line-no">294</span><span id="line-294">                                        PDAction action = link.getAction();</span>
<span class="source-line-no">295</span><span id="line-295">                                        if ((action instanceof PDActionURI)</span>
<span class="source-line-no">296</span><span id="line-296">                                                || (action instanceof PDActionLaunch)</span>
<span class="source-line-no">297</span><span id="line-297">                                                || (action instanceof PDActionRemoteGoTo)</span>
<span class="source-line-no">298</span><span id="line-298">                                                || (action instanceof PDActionImportData)</span>
<span class="source-line-no">299</span><span id="line-299">                                        ) {</span>
<span class="source-line-no">300</span><span id="line-300">                                            keep = true;</span>
<span class="source-line-no">301</span><span id="line-301">                                        }</span>
<span class="source-line-no">302</span><span id="line-302">                                    }</span>
<span class="source-line-no">303</span><span id="line-303">                                    return keep;</span>
<span class="source-line-no">304</span><span id="line-304">                                }</span>
<span class="source-line-no">305</span><span id="line-305">                            };</span>
<span class="source-line-no">306</span><span id="line-306">                            documentCatalog.getPages().forEach(page -&gt; {</span>
<span class="source-line-no">307</span><span id="line-307">                                try {</span>
<span class="source-line-no">308</span><span id="line-308">                                    notAllowedAnnotationCounterList.add(page.getAnnotations(notAllowedAnnotationFilter).size());</span>
<span class="source-line-no">309</span><span id="line-309">                                } catch (IOException e) {</span>
<span class="source-line-no">310</span><span id="line-310">                                    throw new RuntimeException(e);</span>
<span class="source-line-no">311</span><span id="line-311">                                }</span>
<span class="source-line-no">312</span><span id="line-312">                            });</span>
<span class="source-line-no">313</span><span id="line-313">                            if (notAllowedAnnotationCounterList.stream().reduce(0, Integer::sum) == 0) {</span>
<span class="source-line-no">314</span><span id="line-314">                                isSafe = true;</span>
<span class="source-line-no">315</span><span id="line-315">                            }</span>
<span class="source-line-no">316</span><span id="line-316">                        }</span>
<span class="source-line-no">317</span><span id="line-317">                    }</span>
<span class="source-line-no">318</span><span id="line-318">                }</span>
<span class="source-line-no">319</span><span id="line-319">            }</span>
<span class="source-line-no">320</span><span id="line-320">        } catch (Exception e) {</span>
<span class="source-line-no">321</span><span id="line-321">            isSafe = false;</span>
<span class="source-line-no">322</span><span id="line-322">        }</span>
<span class="source-line-no">323</span><span id="line-323">        return isSafe;</span>
<span class="source-line-no">324</span><span id="line-324">    }</span>
<span class="source-line-no">325</span><span id="line-325"></span>
<span class="source-line-no">326</span><span id="line-326">    /**</span>
<span class="source-line-no">327</span><span id="line-327">     * Remove as much as possible metadata from the provided PDF document object.</span>
<span class="source-line-no">328</span><span id="line-328">     *</span>
<span class="source-line-no">329</span><span id="line-329">     * @param document PDFBox PDF document object on which metadata must be removed.</span>
<span class="source-line-no">330</span><span id="line-330">     * @see "https://gist.github.com/righettod/d7e07443c43d393a39de741a0d920069"</span>
<span class="source-line-no">331</span><span id="line-331">     * @see "https://pdfbox.apache.org/"</span>
<span class="source-line-no">332</span><span id="line-332">     * @see "https://mvnrepository.com/artifact/org.apache.pdfbox/pdfbox"</span>
<span class="source-line-no">333</span><span id="line-333">     */</span>
<span class="source-line-no">334</span><span id="line-334">    public static void clearPDFMetadata(PDDocument document) {</span>
<span class="source-line-no">335</span><span id="line-335">        if (document != null) {</span>
<span class="source-line-no">336</span><span id="line-336">            PDDocumentInformation infoEmpty = new PDDocumentInformation();</span>
<span class="source-line-no">337</span><span id="line-337">            document.setDocumentInformation(infoEmpty);</span>
<span class="source-line-no">338</span><span id="line-338">            PDMetadata newMetadataEmpty = new PDMetadata(document);</span>
<span class="source-line-no">339</span><span id="line-339">            document.getDocumentCatalog().setMetadata(newMetadataEmpty);</span>
<span class="source-line-no">340</span><span id="line-340">        }</span>
<span class="source-line-no">341</span><span id="line-341">    }</span>
<span class="source-line-no">342</span><span id="line-342"></span>
<span class="source-line-no">343</span><span id="line-343"></span>
<span class="source-line-no">344</span><span id="line-344">    /**</span>
<span class="source-line-no">345</span><span id="line-345">     * Validate that the URL provided is really a relative URL.</span>
<span class="source-line-no">346</span><span id="line-346">     *</span>
<span class="source-line-no">347</span><span id="line-347">     * @param targetUrl URL to validate.</span>
<span class="source-line-no">348</span><span id="line-348">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">349</span><span id="line-349">     * @see "https://portswigger.net/web-security/ssrf"</span>
<span class="source-line-no">350</span><span id="line-350">     * @see "https://stackoverflow.com/q/6785442"</span>
<span class="source-line-no">351</span><span id="line-351">     */</span>
<span class="source-line-no">352</span><span id="line-352">    public static boolean isRelativeURL(String targetUrl) {</span>
<span class="source-line-no">353</span><span id="line-353">        boolean isValid = false;</span>
<span class="source-line-no">354</span><span id="line-354">        //Reject any URL encoded content and URL starting with a double slash</span>
<span class="source-line-no">355</span><span id="line-355">        //Reject any URL contains credentials or fragment to prevent potential bypasses</span>
<span class="source-line-no">356</span><span id="line-356">        String work = targetUrl;</span>
<span class="source-line-no">357</span><span id="line-357">        if (!work.contains("%") &amp;&amp; !work.contains("@") &amp;&amp; !work.contains("#") &amp;&amp; !work.startsWith("//")) {</span>
<span class="source-line-no">358</span><span id="line-358">            //Creation of a URL object must fail</span>
<span class="source-line-no">359</span><span id="line-359">            try {</span>
<span class="source-line-no">360</span><span id="line-360">                new URL(work);</span>
<span class="source-line-no">361</span><span id="line-361">                isValid = false;</span>
<span class="source-line-no">362</span><span id="line-362">            } catch (MalformedURLException mf) {</span>
<span class="source-line-no">363</span><span id="line-363">                //Last check to be sure (for prod usage compile the pattern one time)</span>
<span class="source-line-no">364</span><span id="line-364">                isValid = Pattern.compile("^/[a-z0-9]+", Pattern.CASE_INSENSITIVE).matcher(work).find();</span>
<span class="source-line-no">365</span><span id="line-365">            }</span>
<span class="source-line-no">366</span><span id="line-366">        }</span>
<span class="source-line-no">367</span><span id="line-367">        return isValid;</span>
<span class="source-line-no">368</span><span id="line-368">    }</span>
<span class="source-line-no">369</span><span id="line-369"></span>
<span class="source-line-no">370</span><span id="line-370">    /**</span>
<span class="source-line-no">371</span><span id="line-371">     * Apply a collection of validations on a ZIP file provided:&lt;br&gt;</span>
<span class="source-line-no">372</span><span id="line-372">     * - Real ZIP file&lt;br&gt;</span>
<span class="source-line-no">373</span><span id="line-373">     * - Contain less than a specified level of deepness.&lt;br&gt;</span>
<span class="source-line-no">374</span><span id="line-374">     * - Do not contain Zip-Slip entry path.&lt;br&gt;</span>
<span class="source-line-no">375</span><span id="line-375">     *</span>
<span class="source-line-no">376</span><span id="line-376">     * @param zipFilePath       Filename of the ZIP file to check.</span>
<span class="source-line-no">377</span><span id="line-377">     * @param maxLevelDeepness  Threshold of deepness above which a ZIP archive will be rejected.</span>
<span class="source-line-no">378</span><span id="line-378">     * @param rejectArchiveFile Flag to specify if presence of any archive entry will cause the rejection of the ZIP file.</span>
<span class="source-line-no">379</span><span id="line-379">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">380</span><span id="line-380">     * @see "https://rules.sonarsource.com/java/type/Security%20Hotspot/RSPEC-5042"</span>
<span class="source-line-no">381</span><span id="line-381">     * @see "https://security.snyk.io/research/zip-slip-vulnerability"</span>
<span class="source-line-no">382</span><span id="line-382">     * @see "https://en.wikipedia.org/wiki/Zip_bomb"</span>
<span class="source-line-no">383</span><span id="line-383">     * @see "https://github.com/ptoomey3/evilarc"</span>
<span class="source-line-no">384</span><span id="line-384">     * @see "https://github.com/abdulfatir/ZipBomb"</span>
<span class="source-line-no">385</span><span id="line-385">     * @see "https://www.baeldung.com/cs/zip-bomb"</span>
<span class="source-line-no">386</span><span id="line-386">     * @see "https://thesecurityvault.com/attacks-with-zip-files-and-mitigations/"</span>
<span class="source-line-no">387</span><span id="line-387">     * @see "https://wiki.sei.cmu.edu/confluence/display/java/IDS04-J.+Safely+extract+files+from+ZipInputStream"</span>
<span class="source-line-no">388</span><span id="line-388">     */</span>
<span class="source-line-no">389</span><span id="line-389">    public static boolean isZIPSafe(String zipFilePath, int maxLevelDeepness, boolean rejectArchiveFile) {</span>
<span class="source-line-no">390</span><span id="line-390">        List&lt;String&gt; archiveExtensions = Arrays.asList("zip", "tar", "7z", "gz", "jar", "phar", "bz2", "tgz");</span>
<span class="source-line-no">391</span><span id="line-391">        boolean isSafe = false;</span>
<span class="source-line-no">392</span><span id="line-392">        try {</span>
<span class="source-line-no">393</span><span id="line-393">            File zipFile = new File(zipFilePath);</span>
<span class="source-line-no">394</span><span id="line-394">            if (zipFile.exists() &amp;&amp; zipFile.canRead() &amp;&amp; zipFile.isFile() &amp;&amp; maxLevelDeepness &gt; 0) {</span>
<span class="source-line-no">395</span><span id="line-395">                //Step 1: Try to load the file, if its fail then it imply that is not a valid ZIP file</span>
<span class="source-line-no">396</span><span id="line-396">                try (ZipFile zipArch = new ZipFile(zipFile)) {</span>
<span class="source-line-no">397</span><span id="line-397">                    //Step 2: Parse entries</span>
<span class="source-line-no">398</span><span id="line-398">                    long deepness = 0;</span>
<span class="source-line-no">399</span><span id="line-399">                    ZipEntry zipEntry;</span>
<span class="source-line-no">400</span><span id="line-400">                    String entryExtension;</span>
<span class="source-line-no">401</span><span id="line-401">                    String zipEntryName;</span>
<span class="source-line-no">402</span><span id="line-402">                    boolean validationsFailed = false;</span>
<span class="source-line-no">403</span><span id="line-403">                    Enumeration&lt;? extends ZipEntry&gt; entries = zipArch.entries();</span>
<span class="source-line-no">404</span><span id="line-404">                    while (entries.hasMoreElements()) {</span>
<span class="source-line-no">405</span><span id="line-405">                        zipEntry = entries.nextElement();</span>
<span class="source-line-no">406</span><span id="line-406">                        zipEntryName = zipEntry.getName();</span>
<span class="source-line-no">407</span><span id="line-407">                        entryExtension = zipEntryName.substring(zipEntryName.lastIndexOf(".") + 1).toLowerCase(Locale.ROOT).trim();</span>
<span class="source-line-no">408</span><span id="line-408">                        //Step 2a: Check if the current entry is an archive file</span>
<span class="source-line-no">409</span><span id="line-409">                        if (rejectArchiveFile &amp;&amp; archiveExtensions.contains(entryExtension)) {</span>
<span class="source-line-no">410</span><span id="line-410">                            validationsFailed = true;</span>
<span class="source-line-no">411</span><span id="line-411">                            break;</span>
<span class="source-line-no">412</span><span id="line-412">                        }</span>
<span class="source-line-no">413</span><span id="line-413">                        //Step 2b: Check that level of deepness is inferior to the threshold specified</span>
<span class="source-line-no">414</span><span id="line-414">                        if (zipEntryName.contains("/")) {</span>
<span class="source-line-no">415</span><span id="line-415">                            //Determine deepness by inspecting the entry name.</span>
<span class="source-line-no">416</span><span id="line-416">                            //Indeed, folder will be represented like this: folder/folder/folder/</span>
<span class="source-line-no">417</span><span id="line-417">                            //So we can count the number of "/" to identify the deepness of the entry</span>
<span class="source-line-no">418</span><span id="line-418">                            deepness = zipEntryName.chars().filter(ch -&gt; ch == '/').count();</span>
<span class="source-line-no">419</span><span id="line-419">                            if (deepness &gt; maxLevelDeepness) {</span>
<span class="source-line-no">420</span><span id="line-420">                                validationsFailed = true;</span>
<span class="source-line-no">421</span><span id="line-421">                                break;</span>
<span class="source-line-no">422</span><span id="line-422">                            }</span>
<span class="source-line-no">423</span><span id="line-423">                        }</span>
<span class="source-line-no">424</span><span id="line-424">                        //Step 2c: Check if any entries match pattern of zip slip payload</span>
<span class="source-line-no">425</span><span id="line-425">                        if (zipEntryName.contains("..\\") || zipEntryName.contains("../")) {</span>
<span class="source-line-no">426</span><span id="line-426">                            validationsFailed = true;</span>
<span class="source-line-no">427</span><span id="line-427">                            break;</span>
<span class="source-line-no">428</span><span id="line-428">                        }</span>
<span class="source-line-no">429</span><span id="line-429">                    }</span>
<span class="source-line-no">430</span><span id="line-430">                    if (!validationsFailed) {</span>
<span class="source-line-no">431</span><span id="line-431">                        isSafe = true;</span>
<span class="source-line-no">432</span><span id="line-432">                    }</span>
<span class="source-line-no">433</span><span id="line-433">                }</span>
<span class="source-line-no">434</span><span id="line-434">            }</span>
<span class="source-line-no">435</span><span id="line-435">        } catch (Exception e) {</span>
<span class="source-line-no">436</span><span id="line-436">            isSafe = false;</span>
<span class="source-line-no">437</span><span id="line-437">        }</span>
<span class="source-line-no">438</span><span id="line-438">        return isSafe;</span>
<span class="source-line-no">439</span><span id="line-439">    }</span>
<span class="source-line-no">440</span><span id="line-440"></span>
<span class="source-line-no">441</span><span id="line-441">    /**</span>
<span class="source-line-no">442</span><span id="line-442">     * Identify the mime type of the content specified (array of bytes).&lt;br&gt;</span>
<span class="source-line-no">443</span><span id="line-443">     * Note that it cannot be fully trusted (see the tweet '1595824709186519041' referenced), so, additional validations are required.</span>
<span class="source-line-no">444</span><span id="line-444">     *</span>
<span class="source-line-no">445</span><span id="line-445">     * @param content The content as an array of bytes.</span>
<span class="source-line-no">446</span><span id="line-446">     * @return The mime type in lower case or null if it cannot be identified.</span>
<span class="source-line-no">447</span><span id="line-447">     * @see "https://twitter.com/righettod/status/1595824709186519041"</span>
<span class="source-line-no">448</span><span id="line-448">     * @see "https://tika.apache.org/"</span>
<span class="source-line-no">449</span><span id="line-449">     * @see "https://mvnrepository.com/artifact/org.apache.tika/tika-core"</span>
<span class="source-line-no">450</span><span id="line-450">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types"</span>
<span class="source-line-no">451</span><span id="line-451">     * @see "https://www.iana.org/assignments/media-types/media-types.xhtml"</span>
<span class="source-line-no">452</span><span id="line-452">     */</span>
<span class="source-line-no">453</span><span id="line-453">    public static String identifyMimeType(byte[] content) {</span>
<span class="source-line-no">454</span><span id="line-454">        String mimeType = null;</span>
<span class="source-line-no">455</span><span id="line-455">        if (content != null &amp;&amp; content.length &gt; 0) {</span>
<span class="source-line-no">456</span><span id="line-456">            Detector detector = new DefaultDetector(MimeTypes.getDefaultMimeTypes());</span>
<span class="source-line-no">457</span><span id="line-457">            Metadata metadata = new Metadata();</span>
<span class="source-line-no">458</span><span id="line-458">            try {</span>
<span class="source-line-no">459</span><span id="line-459">                try (TemporaryResources temporaryResources = new TemporaryResources(); TikaInputStream tikaInputStream = TikaInputStream.get(new ByteArrayInputStream(content), temporaryResources, metadata)) {</span>
<span class="source-line-no">460</span><span id="line-460">                    MediaType mt = detector.detect(tikaInputStream, metadata);</span>
<span class="source-line-no">461</span><span id="line-461">                    if (mt != null) {</span>
<span class="source-line-no">462</span><span id="line-462">                        mimeType = mt.toString().toLowerCase(Locale.ROOT);</span>
<span class="source-line-no">463</span><span id="line-463">                    }</span>
<span class="source-line-no">464</span><span id="line-464">                }</span>
<span class="source-line-no">465</span><span id="line-465">            } catch (IOException ioe) {</span>
<span class="source-line-no">466</span><span id="line-466">                mimeType = null;</span>
<span class="source-line-no">467</span><span id="line-467">            }</span>
<span class="source-line-no">468</span><span id="line-468">        }</span>
<span class="source-line-no">469</span><span id="line-469">        return mimeType;</span>
<span class="source-line-no">470</span><span id="line-470">    }</span>
<span class="source-line-no">471</span><span id="line-471"></span>
<span class="source-line-no">472</span><span id="line-472">    /**</span>
<span class="source-line-no">473</span><span id="line-473">     * Apply a collection of validations on a string expected to be an public IP address:&lt;br&gt;</span>
<span class="source-line-no">474</span><span id="line-474">     * - Is a valid IP v4 or v6 address.&lt;br&gt;</span>
<span class="source-line-no">475</span><span id="line-475">     * - Is public from an Internet perspective.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">476</span><span id="line-476">     * &lt;b&gt;Note:&lt;/b&gt; I often see missing such validation in the value read from HTTP request headers like "X-Forwarded-For" or "Forwarded".</span>
<span class="source-line-no">477</span><span id="line-477">     * &lt;br&gt;</span>
<span class="source-line-no">478</span><span id="line-478">     * &lt;b&gt;Note for IPv6:&lt;/b&gt; I used documentation found so it is really experimental!</span>
<span class="source-line-no">479</span><span id="line-479">     *</span>
<span class="source-line-no">480</span><span id="line-480">     * @param ip String expected to be a valid IP address.</span>
<span class="source-line-no">481</span><span id="line-481">     * @return True only if the string pass all validations.</span>
<span class="source-line-no">482</span><span id="line-482">     * @see "https://commons.apache.org/proper/commons-validator/"</span>
<span class="source-line-no">483</span><span id="line-483">     * @see "https://commons.apache.org/proper/commons-validator/apidocs/org/apache/commons/validator/routines/InetAddressValidator.html"</span>
<span class="source-line-no">484</span><span id="line-484">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"</span>
<span class="source-line-no">485</span><span id="line-485">     * @see "https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_Orange_Tsai_Talk.pdf"</span>
<span class="source-line-no">486</span><span id="line-486">     * @see "https://cheatsheetseries.owasp.org/assets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet_SSRF_Bible.pdf"</span>
<span class="source-line-no">487</span><span id="line-487">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For"</span>
<span class="source-line-no">488</span><span id="line-488">     * @see "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded"</span>
<span class="source-line-no">489</span><span id="line-489">     * @see "https://ipcisco.com/lesson/ipv6-address/"</span>
<span class="source-line-no">490</span><span id="line-490">     * @see "https://www.juniper.net/documentation/us/en/software/junos/interfaces-security-devices/topics/topic-map/security-interface-ipv4-ipv6-protocol.html"</span>
<span class="source-line-no">491</span><span id="line-491">     * @see "https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/net/InetAddress.html#getByName(java.lang.String)"</span>
<span class="source-line-no">492</span><span id="line-492">     * @see "https://www.arin.net/reference/research/statistics/address_filters/"</span>
<span class="source-line-no">493</span><span id="line-493">     * @see "https://en.wikipedia.org/wiki/Multicast_address"</span>
<span class="source-line-no">494</span><span id="line-494">     * @see "https://stackoverflow.com/a/5619409"</span>
<span class="source-line-no">495</span><span id="line-495">     * @see "https://www.ripe.net/media/documents/ipv6-address-types.pdf"</span>
<span class="source-line-no">496</span><span id="line-496">     * @see "https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.xhtml"</span>
<span class="source-line-no">497</span><span id="line-497">     * @see "https://developer.android.com/reference/java/net/Inet6Address"</span>
<span class="source-line-no">498</span><span id="line-498">     * @see "https://en.wikipedia.org/wiki/Unique_local_address"</span>
<span class="source-line-no">499</span><span id="line-499">     */</span>
<span class="source-line-no">500</span><span id="line-500">    public static boolean isPublicIPAddress(String ip) {</span>
<span class="source-line-no">501</span><span id="line-501">        boolean isValid = false;</span>
<span class="source-line-no">502</span><span id="line-502">        try {</span>
<span class="source-line-no">503</span><span id="line-503">            //Quick validation on the string itself based on characters used to compose an IP v4/v6 address</span>
<span class="source-line-no">504</span><span id="line-504">            if (Pattern.matches("[0-9a-fA-F:.]+", ip)) {</span>
<span class="source-line-no">505</span><span id="line-505">                //If OK then use the dedicated InetAddressValidator from Apache Commons Validator</span>
<span class="source-line-no">506</span><span id="line-506">                if (InetAddressValidator.getInstance().isValid(ip)) {</span>
<span class="source-line-no">507</span><span id="line-507">                    //If OK then validate that is an public IP address</span>
<span class="source-line-no">508</span><span id="line-508">                    //From Javadoc for "InetAddress.getByName": If a literal IP address is supplied, only the validity of the address format is checked.</span>
<span class="source-line-no">509</span><span id="line-509">                    InetAddress addr = InetAddress.getByName(ip);</span>
<span class="source-line-no">510</span><span id="line-510">                    isValid = (!addr.isAnyLocalAddress() &amp;&amp; !addr.isLinkLocalAddress()</span>
<span class="source-line-no">511</span><span id="line-511">                            &amp;&amp; !addr.isLoopbackAddress() &amp;&amp; !addr.isMulticastAddress()</span>
<span class="source-line-no">512</span><span id="line-512">                            &amp;&amp; !addr.isSiteLocalAddress());</span>
<span class="source-line-no">513</span><span id="line-513">                    //If OK and the IP is an V6 one then make additional validation because the built-in Java API will let pass some V6 IP</span>
<span class="source-line-no">514</span><span id="line-514">                    //For the prefix map, the start of the key indicates if the value is a regex or a string</span>
<span class="source-line-no">515</span><span id="line-515">                    if (isValid &amp;&amp; (addr instanceof Inet6Address)) {</span>
<span class="source-line-no">516</span><span id="line-516">                        Map&lt;String, String&gt; prefixes = new HashMap&lt;&gt;();</span>
<span class="source-line-no">517</span><span id="line-517">                        prefixes.put("REGEX_LOOPBACK", "^(0|:)+1$");</span>
<span class="source-line-no">518</span><span id="line-518">                        prefixes.put("REGEX_UNIQUE-LOCAL-ADDRESSES", "^f(c|d)[a-f0-9]{2}:.*$");</span>
<span class="source-line-no">519</span><span id="line-519">                        prefixes.put("STRING_LINK-LOCAL-ADDRESSES", "fe80:");</span>
<span class="source-line-no">520</span><span id="line-520">                        prefixes.put("REGEX_TEREDO", "^2001:[0]*:.*$");</span>
<span class="source-line-no">521</span><span id="line-521">                        prefixes.put("REGEX_BENCHMARKING", "^2001:[0]*2:.*$");</span>
<span class="source-line-no">522</span><span id="line-522">                        prefixes.put("REGEX_ORCHID", "^2001:[0]*10:.*$");</span>
<span class="source-line-no">523</span><span id="line-523">                        prefixes.put("STRING_DOCUMENTATION", "2001:db8:");</span>
<span class="source-line-no">524</span><span id="line-524">                        prefixes.put("STRING_GLOBAL-UNICAST", "2000:");</span>
<span class="source-line-no">525</span><span id="line-525">                        prefixes.put("REGEX_MULTICAST", "^ff[0-9]{2}:.*$");</span>
<span class="source-line-no">526</span><span id="line-526">                        final List&lt;Boolean&gt; results = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">527</span><span id="line-527">                        final String ipLower = ip.trim().toLowerCase(Locale.ROOT);</span>
<span class="source-line-no">528</span><span id="line-528">                        prefixes.forEach((addressType, expr) -&gt; {</span>
<span class="source-line-no">529</span><span id="line-529">                            String exprLower = expr.trim().toLowerCase();</span>
<span class="source-line-no">530</span><span id="line-530">                            if (addressType.startsWith("STRING_")) {</span>
<span class="source-line-no">531</span><span id="line-531">                                results.add(ipLower.startsWith(exprLower));</span>
<span class="source-line-no">532</span><span id="line-532">                            } else {</span>
<span class="source-line-no">533</span><span id="line-533">                                results.add(Pattern.matches(exprLower, ipLower));</span>
<span class="source-line-no">534</span><span id="line-534">                            }</span>
<span class="source-line-no">535</span><span id="line-535">                        });</span>
<span class="source-line-no">536</span><span id="line-536">                        isValid = ((results.size() == prefixes.size()) &amp;&amp; !results.contains(Boolean.TRUE));</span>
<span class="source-line-no">537</span><span id="line-537">                    }</span>
<span class="source-line-no">538</span><span id="line-538">                }</span>
<span class="source-line-no">539</span><span id="line-539">            }</span>
<span class="source-line-no">540</span><span id="line-540">        } catch (Exception e) {</span>
<span class="source-line-no">541</span><span id="line-541">            isValid = false;</span>
<span class="source-line-no">542</span><span id="line-542">        }</span>
<span class="source-line-no">543</span><span id="line-543">        return isValid;</span>
<span class="source-line-no">544</span><span id="line-544">    }</span>
<span class="source-line-no">545</span><span id="line-545"></span>
<span class="source-line-no">546</span><span id="line-546">    /**</span>
<span class="source-line-no">547</span><span id="line-547">     * Compute a SHA256 hash from an input composed of a collection of strings.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">548</span><span id="line-548">     * This method take care to build the source string in a way to prevent this source string to be prone to abuse targeting the different parts composing it.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">549</span><span id="line-549">     * Example of possible abuse without precautions applied during the hash calculation logic:&lt;br&gt;</span>
<span class="source-line-no">550</span><span id="line-550">     * Hash of &lt;code&gt;SHA256("Hello", "My", "World!!!")&lt;/code&gt; will be equals to the hash of &lt;code&gt;SHA256("Hell", "oMyW", "orld!!!")&lt;/code&gt;.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">551</span><span id="line-551">     * This method ensure that both hash above will be different.</span>
<span class="source-line-no">552</span><span id="line-552">     *</span>
<span class="source-line-no">553</span><span id="line-553">     * @param parts Ordered list of strings to use to build the input string for which the hash must be computed on. No null value is accepted on object composing the collection.</span>
<span class="source-line-no">554</span><span id="line-554">     * @return The hash, as an array of bytes, to allow caller to convert it to the final representation wanted (HEX, Base64, etc.). If the collection passed is null or empty then the method return null.</span>
<span class="source-line-no">555</span><span id="line-555">     * @throws Exception If any exception occurs</span>
<span class="source-line-no">556</span><span id="line-556">     * @see "https://pentesterlab.com/badges/codereview"</span>
<span class="source-line-no">557</span><span id="line-557">     */</span>
<span class="source-line-no">558</span><span id="line-558">    public static byte[] computeHashNoProneToAbuseOnParts(List&lt;String&gt; parts) throws Exception {</span>
<span class="source-line-no">559</span><span id="line-559">        byte[] hash = null;</span>
<span class="source-line-no">560</span><span id="line-560">        if (parts != null &amp;&amp; !parts.isEmpty()) {</span>
<span class="source-line-no">561</span><span id="line-561">            //Ensure that not part is null</span>
<span class="source-line-no">562</span><span id="line-562">            if (parts.stream().anyMatch(Objects::isNull)) {</span>
<span class="source-line-no">563</span><span id="line-563">                throw new IllegalArgumentException("No part must be null!");</span>
<span class="source-line-no">564</span><span id="line-564">            }</span>
<span class="source-line-no">565</span><span id="line-565">            String separator = "|";</span>
<span class="source-line-no">566</span><span id="line-566">            MessageDigest digest = MessageDigest.getInstance("SHA-256");</span>
<span class="source-line-no">567</span><span id="line-567">            final StringBuilder buffer = new StringBuilder(separator);</span>
<span class="source-line-no">568</span><span id="line-568">            parts.forEach(p -&gt; {</span>
<span class="source-line-no">569</span><span id="line-569">                buffer.append(p).append(separator);</span>
<span class="source-line-no">570</span><span id="line-570">            });</span>
<span class="source-line-no">571</span><span id="line-571">            hash = digest.digest(buffer.toString().getBytes(StandardCharsets.UTF_8));</span>
<span class="source-line-no">572</span><span id="line-572">        }</span>
<span class="source-line-no">573</span><span id="line-573">        return hash;</span>
<span class="source-line-no">574</span><span id="line-574">    }</span>
<span class="source-line-no">575</span><span id="line-575"></span>
<span class="source-line-no">576</span><span id="line-576">    /**</span>
<span class="source-line-no">577</span><span id="line-577">     * Ensure that an XML file only uses DTD/XSD references (called System Identifier) present in the allowed list provided.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">578</span><span id="line-578">     * The code is based on the validation implemented into the OpenJDK 21, by the class &lt;b&gt;&lt;a href="https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.prefs/share/classes/java/util/prefs/XmlSupport.java"&gt;java.util.prefs.XmlSupport&lt;/a&gt;&lt;/b&gt;, in the method &lt;b&gt;&lt;a href="https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.prefs/share/classes/java/util/prefs/XmlSupport.java#L240"&gt;loadPrefsDoc()&lt;/a&gt;&lt;/b&gt;.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">579</span><span id="line-579">     * The method also ensure that no Public Identifier is used to prevent potential bypasses of the validations.</span>
<span class="source-line-no">580</span><span id="line-580">     *</span>
<span class="source-line-no">581</span><span id="line-581">     * @param xmlFilePath              Filename of the XML file to check.</span>
<span class="source-line-no">582</span><span id="line-582">     * @param allowedSystemIdentifiers List of URL allowed for System Identifier specified for any XSD/DTD references.</span>
<span class="source-line-no">583</span><span id="line-583">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">584</span><span id="line-584">     * @see "https://www.w3schools.com/xml/prop_documenttype_systemid.asp"</span>
<span class="source-line-no">585</span><span id="line-585">     * @see "https://www.ibm.com/docs/en/integration-bus/9.0.0?topic=doctypedecl-xml-systemid"</span>
<span class="source-line-no">586</span><span id="line-586">     * @see "https://www.liquid-technologies.com/Reference/Glossary/XML_DocType.html"</span>
<span class="source-line-no">587</span><span id="line-587">     * @see "https://www.xml.com/pub/98/08/xmlqna0.html"</span>
<span class="source-line-no">588</span><span id="line-588">     * @see "https://github.com/openjdk/jdk/blob/jdk-21%2B35/src/java.prefs/share/classes/java/util/prefs/XmlSupport.java#L397"</span>
<span class="source-line-no">589</span><span id="line-589">     * @see "https://en.wikipedia.org/wiki/Formal_Public_Identifier"</span>
<span class="source-line-no">590</span><span id="line-590">     */</span>
<span class="source-line-no">591</span><span id="line-591">    public static boolean isXMLOnlyUseAllowedXSDorDTD(String xmlFilePath, final List&lt;String&gt; allowedSystemIdentifiers) {</span>
<span class="source-line-no">592</span><span id="line-592">        boolean isSafe = false;</span>
<span class="source-line-no">593</span><span id="line-593">        final String errorTemplate = "Non allowed %s ID detected!";</span>
<span class="source-line-no">594</span><span id="line-594">        final String emptyFakeDTD = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!ELEMENT dummy EMPTY&gt;";</span>
<span class="source-line-no">595</span><span id="line-595">        final String emptyFakeXSD = "&lt;xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"&gt; &lt;xs:element name=\"dummy\"/&gt;&lt;/xs:schema&gt;";</span>
<span class="source-line-no">596</span><span id="line-596"></span>
<span class="source-line-no">597</span><span id="line-597">        if (allowedSystemIdentifiers == null || allowedSystemIdentifiers.isEmpty()) {</span>
<span class="source-line-no">598</span><span id="line-598">            throw new IllegalArgumentException("At least one SID must be specified!");</span>
<span class="source-line-no">599</span><span id="line-599">        }</span>
<span class="source-line-no">600</span><span id="line-600">        File xmlFile = new File(xmlFilePath);</span>
<span class="source-line-no">601</span><span id="line-601">        if (xmlFile.exists() &amp;&amp; xmlFile.canRead() &amp;&amp; xmlFile.isFile()) {</span>
<span class="source-line-no">602</span><span id="line-602">            try {</span>
<span class="source-line-no">603</span><span id="line-603">                EntityResolver resolverValidator = (publicId, systemId) -&gt; {</span>
<span class="source-line-no">604</span><span id="line-604">                    if (publicId != null) {</span>
<span class="source-line-no">605</span><span id="line-605">                        throw new SAXException(String.format(errorTemplate, "PUBLIC"));</span>
<span class="source-line-no">606</span><span id="line-606">                    }</span>
<span class="source-line-no">607</span><span id="line-607">                    if (!allowedSystemIdentifiers.contains(systemId)) {</span>
<span class="source-line-no">608</span><span id="line-608">                        throw new SAXException(String.format(errorTemplate, "SYSTEM"));</span>
<span class="source-line-no">609</span><span id="line-609">                    }</span>
<span class="source-line-no">610</span><span id="line-610">                    //If it is OK then return a empty DTD/XSD</span>
<span class="source-line-no">611</span><span id="line-611">                    return new InputSource(new StringReader(systemId.toLowerCase().endsWith(".dtd") ? emptyFakeDTD : emptyFakeXSD));</span>
<span class="source-line-no">612</span><span id="line-612">                };</span>
<span class="source-line-no">613</span><span id="line-613">                DocumentBuilderFactory dbfInstance = DocumentBuilderFactory.newInstance();</span>
<span class="source-line-no">614</span><span id="line-614">                dbfInstance.setIgnoringElementContentWhitespace(true);</span>
<span class="source-line-no">615</span><span id="line-615">                dbfInstance.setXIncludeAware(false);</span>
<span class="source-line-no">616</span><span id="line-616">                dbfInstance.setValidating(false);</span>
<span class="source-line-no">617</span><span id="line-617">                dbfInstance.setCoalescing(true);</span>
<span class="source-line-no">618</span><span id="line-618">                dbfInstance.setIgnoringComments(false);</span>
<span class="source-line-no">619</span><span id="line-619">                DocumentBuilder builder = dbfInstance.newDocumentBuilder();</span>
<span class="source-line-no">620</span><span id="line-620">                builder.setEntityResolver(resolverValidator);</span>
<span class="source-line-no">621</span><span id="line-621">                Document doc = builder.parse(xmlFile);</span>
<span class="source-line-no">622</span><span id="line-622">                isSafe = (doc != null);</span>
<span class="source-line-no">623</span><span id="line-623">            } catch (SAXException | IOException | ParserConfigurationException e) {</span>
<span class="source-line-no">624</span><span id="line-624">                isSafe = false;</span>
<span class="source-line-no">625</span><span id="line-625">            }</span>
<span class="source-line-no">626</span><span id="line-626">        }</span>
<span class="source-line-no">627</span><span id="line-627"></span>
<span class="source-line-no">628</span><span id="line-628">        return isSafe;</span>
<span class="source-line-no">629</span><span id="line-629">    }</span>
<span class="source-line-no">630</span><span id="line-630"></span>
<span class="source-line-no">631</span><span id="line-631">    /**</span>
<span class="source-line-no">632</span><span id="line-632">     * Apply a collection of validations on a EXCEL CSV file provided (file was expected to be opened in Microsoft EXCEL):&lt;br&gt;</span>
<span class="source-line-no">633</span><span id="line-633">     * - Real CSV file.&lt;br&gt;</span>
<span class="source-line-no">634</span><span id="line-634">     * - Do not contains any payload related to a CSV injections.&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">635</span><span id="line-635">     * Ensure that, if Apache Commons CSV does not find any record then, the file will be considered as NOT safe (prevent potential bypasses).&lt;br&gt;&lt;br&gt;</span>
<span class="source-line-no">636</span><span id="line-636">     * &lt;b&gt;Note:&lt;/b&gt; Record delimiter used is the &lt;code&gt;,&lt;/code&gt; (comma) character. See the Apache Commons CSV reference provided for EXCEL.&lt;br&gt;</span>
<span class="source-line-no">637</span><span id="line-637">     *</span>
<span class="source-line-no">638</span><span id="line-638">     * @param csvFilePath Filename of the CSV file to check.</span>
<span class="source-line-no">639</span><span id="line-639">     * @return True only if the file pass all validations.</span>
<span class="source-line-no">640</span><span id="line-640">     * @see "https://commons.apache.org/proper/commons-csv/"</span>
<span class="source-line-no">641</span><span id="line-641">     * @see "https://commons.apache.org/proper/commons-csv/apidocs/org/apache/commons/csv/CSVFormat.html#EXCEL"</span>
<span class="source-line-no">642</span><span id="line-642">     * @see "https://www.we45.com/post/your-excel-sheets-are-not-safe-heres-how-to-beat-csv-injection"</span>
<span class="source-line-no">643</span><span id="line-643">     * @see "https://www.whiteoaksecurity.com/blog/2020-4-23-csv-injection-whats-the-risk/"</span>
<span class="source-line-no">644</span><span id="line-644">     * @see "https://book.hacktricks.xyz/pentesting-web/formula-csv-doc-latex-ghostscript-injection"</span>
<span class="source-line-no">645</span><span id="line-645">     * @see "https://owasp.org/www-community/attacks/CSV_Injection"</span>
<span class="source-line-no">646</span><span id="line-646">     * @see "https://payatu.com/blog/csv-injection-basic-to-exploit/"</span>
<span class="source-line-no">647</span><span id="line-647">     * @see "https://cwe.mitre.org/data/definitions/1236.html"</span>
<span class="source-line-no">648</span><span id="line-648">     */</span>
<span class="source-line-no">649</span><span id="line-649">    public static boolean isExcelCSVSafe(String csvFilePath) {</span>
<span class="source-line-no">650</span><span id="line-650">        boolean isSafe;</span>
<span class="source-line-no">651</span><span id="line-651">        final AtomicInteger recordCount = new AtomicInteger();</span>
<span class="source-line-no">652</span><span id="line-652">        final List&lt;Character&gt; payloadDetectionCharacters = List.of('=', '+', '@', '-', '\r', '\t');</span>
<span class="source-line-no">653</span><span id="line-653"></span>
<span class="source-line-no">654</span><span id="line-654">        try {</span>
<span class="source-line-no">655</span><span id="line-655">            final List&lt;String&gt; payloadsIdentified = new ArrayList&lt;&gt;();</span>
<span class="source-line-no">656</span><span id="line-656">            try (Reader in = new FileReader(csvFilePath)) {</span>
<span class="source-line-no">657</span><span id="line-657">                Iterable&lt;CSVRecord&gt; records = CSVFormat.EXCEL.parse(in);</span>
<span class="source-line-no">658</span><span id="line-658">                records.forEach(record -&gt; {</span>
<span class="source-line-no">659</span><span id="line-659">                    record.forEach(recordValue -&gt; {</span>
<span class="source-line-no">660</span><span id="line-660">                        if (recordValue != null &amp;&amp; !recordValue.trim().isEmpty() &amp;&amp; payloadDetectionCharacters.contains(recordValue.trim().charAt(0))) {</span>
<span class="source-line-no">661</span><span id="line-661">                            payloadsIdentified.add(recordValue);</span>
<span class="source-line-no">662</span><span id="line-662">                        }</span>
<span class="source-line-no">663</span><span id="line-663">                        recordCount.getAndIncrement();</span>
<span class="source-line-no">664</span><span id="line-664">                    });</span>
<span class="source-line-no">665</span><span id="line-665">                });</span>
<span class="source-line-no">666</span><span id="line-666">            }</span>
<span class="source-line-no">667</span><span id="line-667">            isSafe = (payloadsIdentified.isEmpty() &amp;&amp; recordCount.get() &gt; 0);</span>
<span class="source-line-no">668</span><span id="line-668">        } catch (Exception e) {</span>
<span class="source-line-no">669</span><span id="line-669">            isSafe = false;</span>
<span class="source-line-no">670</span><span id="line-670">        }</span>
<span class="source-line-no">671</span><span id="line-671"></span>
<span class="source-line-no">672</span><span id="line-672">        return isSafe;</span>
<span class="source-line-no">673</span><span id="line-673">    }</span>
<span class="source-line-no">674</span><span id="line-674"></span>
<span class="source-line-no">675</span><span id="line-675">    /**</span>
<span class="source-line-no">676</span><span id="line-676">     * Provide a way to add an integrity marker (&lt;a href="https://cryptobook.nakov.com/mac-and-key-derivation"&gt;HMAC&lt;/a&gt;) to a serialized object serialized using the &lt;a href="https://www.baeldung.com/java-serialization"&gt;java native system&lt;/a&gt; (binary).&lt;br&gt;</span>
<span class="source-line-no">677</span><span id="line-677">     * The goal is to provide &lt;b&gt;a temporary workaround&lt;/b&gt; to try to prevent deserialization attacks and give time to move to a text-based serialization approach.</span>
<span class="source-line-no">678</span><span id="line-678">     *</span>
<span class="source-line-no">679</span><span id="line-679">     * @param processingMode Define the mode of processing i.e. protect or validate.</span>
<span class="source-line-no">680</span><span id="line-680">     * @param input          When the processing mode is "protect" than the expected input (string) is a java serialized object encoded in Base64 otherwise (processing mode is "validate") expected input is the output of this method when the "protect" mode was used.</span>
<span class="source-line-no">681</span><span id="line-681">     * @param secret         Secret to use to compute the HMAC.</span>
<span class="source-line-no">682</span><span id="line-682">     * @return A map with the following keys: &lt;ul&gt;&lt;li&gt;&lt;b&gt;PROCESSING_MODE&lt;/b&gt;: Processing mode used to compute the result.&lt;/li&gt;&lt;li&gt;&lt;b&gt;STATUS&lt;/b&gt;: A boolean indicating if the processing was successful or not.&lt;/li&gt;&lt;li&gt;&lt;b&gt;RESULT&lt;/b&gt;: Always contains a string representing the protected serialized object in the format &lt;code&gt;[SERIALIZED_OBJECT_BASE64_ENCODED]:[SERIALIZED_OBJECT_HMAC_BASE64_ENCODED]&lt;/code&gt;.&lt;/li&gt;&lt;/ul&gt;</span>
<span class="source-line-no">683</span><span id="line-683">     * @throws Exception If any exception occurs</span>
<span class="source-line-no">684</span><span id="line-684">     * @see "https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html"</span>
<span class="source-line-no">685</span><span id="line-685">     * @see "https://owasp.org/www-project-top-ten/2017/A8_2017-Insecure_Deserialization"</span>
<span class="source-line-no">686</span><span id="line-686">     * @see "https://portswigger.net/web-security/deserialization"</span>
<span class="source-line-no">687</span><span id="line-687">     * @see "https://www.baeldung.com/java-serialization-approaches"</span>
<span class="source-line-no">688</span><span id="line-688">     * @see "https://www.baeldung.com/java-serialization"</span>
<span class="source-line-no">689</span><span id="line-689">     * @see "https://cryptobook.nakov.com/mac-and-key-derivation"</span>
<span class="source-line-no">690</span><span id="line-690">     * @see "https://smattme.com/posts/how-to-generate-hmac-signature-in-java/"</span>
<span class="source-line-no">691</span><span id="line-691">     */</span>
<span class="source-line-no">692</span><span id="line-692">    public static Map&lt;String, Object&gt; ensureSerializedObjectIntegrity(ProcessingMode processingMode, String input, byte[] secret) throws Exception {</span>
<span class="source-line-no">693</span><span id="line-693">        Map&lt;String, Object&gt; results;</span>
<span class="source-line-no">694</span><span id="line-694">        String resultFormatTemplate = "%s:%s";</span>
<span class="source-line-no">695</span><span id="line-695">        //Verify input provided to be consistent</span>
<span class="source-line-no">696</span><span id="line-696">        if (processingMode == null) {</span>
<span class="source-line-no">697</span><span id="line-697">            throw new IllegalArgumentException("The processing mode is mandatory!");</span>
<span class="source-line-no">698</span><span id="line-698">        }</span>
<span class="source-line-no">699</span><span id="line-699">        if (input == null || input.trim().isEmpty()) {</span>
<span class="source-line-no">700</span><span id="line-700">            throw new IllegalArgumentException("Input data is mandatory!");</span>
<span class="source-line-no">701</span><span id="line-701">        }</span>
<span class="source-line-no">702</span><span id="line-702">        if (secret == null || secret.length == 0) {</span>
<span class="source-line-no">703</span><span id="line-703">            throw new IllegalArgumentException("The HMAC secret is mandatory!");</span>
<span class="source-line-no">704</span><span id="line-704">        }</span>
<span class="source-line-no">705</span><span id="line-705">        if (processingMode.equals(ProcessingMode.VALIDATE) &amp;&amp; input.split(":").length != 2) {</span>
<span class="source-line-no">706</span><span id="line-706">            throw new IllegalArgumentException("Input data provided is invalid for the processing mode specified!");</span>
<span class="source-line-no">707</span><span id="line-707">        }</span>
<span class="source-line-no">708</span><span id="line-708">        //Processing</span>
<span class="source-line-no">709</span><span id="line-709">        Base64.Decoder b64Decoder = Base64.getDecoder();</span>
<span class="source-line-no">710</span><span id="line-710">        Base64.Encoder b64Encoder = Base64.getEncoder();</span>
<span class="source-line-no">711</span><span id="line-711">        String hmacAlgorithm = "HmacSHA256";</span>
<span class="source-line-no">712</span><span id="line-712">        Mac mac = Mac.getInstance(hmacAlgorithm);</span>
<span class="source-line-no">713</span><span id="line-713">        SecretKeySpec key = new SecretKeySpec(secret, hmacAlgorithm);</span>
<span class="source-line-no">714</span><span id="line-714">        mac.init(key);</span>
<span class="source-line-no">715</span><span id="line-715">        results = new HashMap&lt;&gt;();</span>
<span class="source-line-no">716</span><span id="line-716">        results.put("PROCESSING_MODE", processingMode.toString());</span>
<span class="source-line-no">717</span><span id="line-717">        switch (processingMode) {</span>
<span class="source-line-no">718</span><span id="line-718">            case PROTECT -&gt; {</span>
<span class="source-line-no">719</span><span id="line-719">                byte[] objectBytes = b64Decoder.decode(input);</span>
<span class="source-line-no">720</span><span id="line-720">                byte[] hmac = mac.doFinal(objectBytes);</span>
<span class="source-line-no">721</span><span id="line-721">                String encodedHmac = b64Encoder.encodeToString(hmac);</span>
<span class="source-line-no">722</span><span id="line-722">                results.put("STATUS", Boolean.TRUE);</span>
<span class="source-line-no">723</span><span id="line-723">                results.put("RESULT", String.format(resultFormatTemplate, input, encodedHmac));</span>
<span class="source-line-no">724</span><span id="line-724">            }</span>
<span class="source-line-no">725</span><span id="line-725">            case VALIDATE -&gt; {</span>
<span class="source-line-no">726</span><span id="line-726">                String[] parts = input.split(":");</span>
<span class="source-line-no">727</span><span id="line-727">                byte[] objectBytes = b64Decoder.decode(parts[0].trim());</span>
<span class="source-line-no">728</span><span id="line-728">                byte[] hmacProvided = b64Decoder.decode(parts[1].trim());</span>
<span class="source-line-no">729</span><span id="line-729">                byte[] hmacComputed = mac.doFinal(objectBytes);</span>
<span class="source-line-no">730</span><span id="line-730">                String encodedHmacComputed = b64Encoder.encodeToString(hmacComputed);</span>
<span class="source-line-no">731</span><span id="line-731">                Boolean hmacIsValid = Arrays.equals(hmacProvided, hmacComputed);</span>
<span class="source-line-no">732</span><span id="line-732">                results.put("STATUS", hmacIsValid);</span>
<span class="source-line-no">733</span><span id="line-733">                results.put("RESULT", String.format(resultFormatTemplate, parts[0].trim(), encodedHmacComputed));</span>
<span class="source-line-no">734</span><span id="line-734">            }</span>
<span class="source-line-no">735</span><span id="line-735">            default -&gt; throw new IllegalArgumentException("Not supported processing mode!");</span>
<span class="source-line-no">736</span><span id="line-736">        }</span>
<span class="source-line-no">737</span><span id="line-737">        return results;</span>
<span class="source-line-no">738</span><span id="line-738">    }</span>
<span class="source-line-no">739</span><span id="line-739">}</span>




























































</pre>
</div>
</main>
</body>
</html>
